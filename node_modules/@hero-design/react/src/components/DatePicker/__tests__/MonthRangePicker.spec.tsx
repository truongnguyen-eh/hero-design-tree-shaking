import React from 'react';
import { waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import renderWithTheme from '../../../testUtils/renderWithTheme';

import MonthRangePicker from '../MonthRangePicker';

describe('rendering', () => {
  it('match snapshot', async () => {
    const { container } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '10/2022',
        }}
      />
    );
    expect(container.firstChild).toMatchSnapshot();
  });

  it('renders two inputs and calendar', async () => {
    const { getByDisplayValue, getByTestId } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '10/2022',
        }}
      />
    );

    await waitFor(() => {
      expect(getByDisplayValue('05/2021')).toBeInTheDocument();
      expect(getByDisplayValue('10/2022')).toBeInTheDocument();
    });

    userEvent.click(getByDisplayValue('05/2021'));

    await waitFor(() => {
      const firstMonthSelect = getByTestId('first-month-select');
      const firstYearSelect = getByTestId('first-year-select');
      const secondMonthSelect = getByTestId('second-month-select');
      const secondYearSelect = getByTestId('second-year-select');

      expect(firstMonthSelect).toSelectItem('May');
      expect(firstYearSelect).toSelectItem('2021');
      expect(secondMonthSelect).toSelectItem('Oct');
      expect(secondYearSelect).toSelectItem('2022');
    });
  });

  it('renders two inputs with correct format', async () => {
    const { getByDisplayValue } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: 'Jan 2021',
          endDate: 'Oct 2022',
        }}
        format="MMM yyyy"
      />
    );

    await waitFor(() => {
      expect(getByDisplayValue('Jan 2021')).toBeInTheDocument();
      expect(getByDisplayValue('Oct 2022')).toBeInTheDocument();
    });
  });
});

describe('interaction', () => {
  it('allows to blur', async () => {
    const onBlur = jest.fn();

    const { getByPlaceholderText } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '10/2021',
        }}
        onBlur={onBlur}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('Start'));
    userEvent.click(document.body);
    expect(onBlur).toHaveBeenCalledTimes(1);
  });

  it('allows to pick start month and then end month', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText, queryByText } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '10/2022',
        }}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('Start'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });

    userEvent.click(getAllByText('Jan')[1]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '01/2021',
        endDate: '10/2022',
      });
      // Calendar is still open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });

    userEvent.click(getAllByText('Feb')[3]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(2);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '05/2021',
        endDate: '02/2022',
      });
      // Calendar is closed
      expect(queryByText('Jan')).not.toBeInTheDocument();
    });
  });

  it('allows to pick end month and then start month', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText, queryByText } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '10/2022',
        }}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('End'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });

    userEvent.click(getAllByText('Feb')[3]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '05/2021',
        endDate: '02/2022',
      });
      // Calendar is still open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });

    userEvent.click(getAllByText('Jan')[1]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(2);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '01/2021',
        endDate: '10/2022',
      });
      // Calendar is closed
      expect(queryByText('Jan')).not.toBeInTheDocument();
    });
  });

  it('resets end month when new start month is after end month', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '10/2022',
        }}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('Start'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });

    userEvent.click(getAllByText('Nov')[3]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '11/2022',
        endDate: undefined,
      });
      // Calendar is still open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });
  });

  it('resets start month when new end month is before start month', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '10/2022',
        }}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('End'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });

    userEvent.click(getAllByText('Mar')[1]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith({
        startDate: undefined,
        endDate: '03/2021',
      });
      // Calendar is still open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });
  });

  it('does not allow to pick a month out of range', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '05/2022',
        }}
        minDate={new Date(2021, 3)}
        maxDate={new Date(2022, 8)}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('Start'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Jan')[1]).toBeVisible();
    });

    await waitFor(() => {
      expect(() => userEvent.click(getAllByText('Jan')[1])).toThrow();
      expect(onChange).not.toBeCalled();
    });

    await waitFor(() => {
      expect(() => userEvent.click(getAllByText('Dec')[3])).toThrow();
      expect(onChange).not.toBeCalled();
    });
  });

  it('does not allow to edit disabled MonthRangePicker', async () => {
    const { queryByText, getByDisplayValue } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '05/2022',
        }}
        minDate={new Date(2021, 3)}
        maxDate={new Date(2022, 8)}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
        disabled
      />
    );

    userEvent.click(getByDisplayValue('05/2021'));

    await waitFor(() => {
      expect(queryByText('Jan')).not.toBeInTheDocument();
    });
  });

  it('does not allow invalid value', () => {
    jest.spyOn(console, 'error').mockImplementation(() => '');

    expect(() =>
      renderWithTheme(
        <MonthRangePicker
          value={{
            startDate: '1111/05/2021',
            endDate: '15111/05/2021',
          }}
        />
      )
    ).toThrowError('Invalid time value');
  });

  it('does not allow to clear value when clearable is false', () => {
    const { getByTestId, queryByTestId } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '05/2022',
        }}
        data-test-id="month-range-picker"
        clearable={false}
      />
    );

    expect(queryByTestId('remove-icon')).not.toBeInTheDocument();

    userEvent.hover(getByTestId('month-range-picker'));

    expect(queryByTestId('remove-icon')).not.toBeInTheDocument();
  });

  it('does not allow to clear value when value is undefined', () => {
    const { getByTestId, queryByTestId } = renderWithTheme(
      <MonthRangePicker data-test-id="month-range-picker" />
    );

    expect(queryByTestId('remove-icon')).not.toBeInTheDocument();

    userEvent.hover(getByTestId('month-range-picker'));

    expect(queryByTestId('remove-icon')).not.toBeInTheDocument();
  });

  it('allows to clear value when startDate is not undefined', () => {
    const { getByTestId, queryByTestId } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2022',
          endDate: undefined,
        }}
        data-test-id="month-range-picker"
      />
    );

    expect(queryByTestId('remove-icon')).not.toBeInTheDocument();

    userEvent.hover(getByTestId('month-range-picker'));

    expect(queryByTestId('remove-icon')).toBeInTheDocument();
  });

  it('allows to clear value when endDate is not undefined', () => {
    const onChange = jest.fn();
    const { getByTestId, queryByTestId } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: undefined,
          endDate: '05/2021',
        }}
        data-test-id="month-range-picker"
        onChange={onChange}
      />
    );

    expect(queryByTestId('remove-icon')).not.toBeInTheDocument();

    userEvent.hover(getByTestId('month-range-picker'));

    expect(queryByTestId('remove-icon')).toBeInTheDocument();
  });

  it('allows to clear value', async () => {
    const onChange = jest.fn();
    const { getByTestId, queryByTestId, container } = renderWithTheme(
      <MonthRangePicker
        value={{
          startDate: '05/2021',
          endDate: '05/2022',
        }}
        data-test-id="month-range-picker"
        onChange={onChange}
      />
    );

    expect(queryByTestId('remove-icon')).not.toBeInTheDocument();
    expect(container.querySelector('.hero-icon-calendar')).toBeInTheDocument();

    userEvent.hover(getByTestId('month-range-picker'));

    expect(container.querySelector('.hero-icon-calendar')).toBeNull();
    userEvent.click(getByTestId('remove-icon'));

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledWith({
        startDate: undefined,
        endDate: undefined,
      });
    });
  });
});
