import React, { useCallback, useMemo, useState } from 'react';
import * as d3 from 'd3';
import { useTheme } from 'styled-components';

import { BarConfig, MatchedSegment, Series, XAxisConfig } from '../../type';
import { CommonProps } from '../../../common';
import { DataValue } from '../../LineChart/types';
import Rect from './Rect';
import TotalBadge from './TotalBadge';
import { clamp } from '../../utils';
import useSeries from '../../common/useSeries';

type BarData = {
  legend: string;
  value: number;
  color: string;
  label: string;
  xAxisLabel: string;
  percent: number;
};

interface BarAreaProps extends CommonProps {
  width: number;
  height: number;
  maxValue: number;
  minValue: number;
  xAxisConfig?: Omit<XAxisConfig, 'maxValue'>;
  highlightedItems?: MatchedSegment;
  barConfig?: BarConfig<DataValue>;
  onMouseOver: (e: PointerEvent, barData: BarData) => void;
  onMouseOut: (e: PointerEvent) => void;
  onMouseMove: (e: PointerEvent) => void;
  selectedLegends: string[];
  data: Array<Series<Array<DataValue>> & { color: string }>;
  size?: BarConfig<unknown>['size'];
}

const matchedHighlightedItems = (
  { legend, label }: { legend?: string; label?: string },
  highlightedItems?: MatchedSegment
) => {
  if (typeof highlightedItems === 'undefined') return undefined;
  const isMatchedSegmentNotEmpty =
    typeof highlightedItems !== 'undefined'
      ? highlightedItems.length > 0
      : false;
  if (isMatchedSegmentNotEmpty) {
    return (
      highlightedItems &&
      highlightedItems.filter(
        (item) => item.label === label && item.legend === legend
      ).length > 0
    );
  }
  return false;
};

const isActiveBar = (
  activeBar: BarData,
  {
    legend,
    rectValue,
    label,
  }: { legend: string; rectValue: number; label: string }
) => {
  return (
    activeBar.legend === legend &&
    activeBar.value === rectValue &&
    activeBar.label === label
  );
};

const MIN_DISPLAY_PERCENTAGE = 4 / 100;

const BarArea = ({
  xAxisConfig,
  height,
  width,
  maxValue,
  minValue,
  'data-test-id': dataTestId,
  highlightedItems,
  barConfig,
  onMouseOver,
  selectedLegends,
  data,
  onMouseOut,
  onMouseMove,
  size = 'large',
}: BarAreaProps) => {
  const theme = useTheme();

  const {
    __hd__: { columnChart: columnChartTheme },
  } = theme;
  const { totalLetterWidth, totalSvgHeight } = columnChartTheme.sizes;

  const { barMarginTop, totalSvgHorizontalPadding } = columnChartTheme.space;

  const labels = useMemo(
    () => xAxisConfig?.labels || [],
    [xAxisConfig?.labels]
  );

  const [activeBar, setActiveBar] = useState<BarData | undefined>(undefined);

  // Data Wrangling: stack the data
  const series = useSeries({
    legends: selectedLegends,
    maxValue,
    minDisplayPercentage: MIN_DISPLAY_PERCENTAGE,
    data,
    labels,
  });

  const yScale = useMemo(() => {
    return d3.scaleLinear().domain([minValue, maxValue]).range([height, 0]);
  }, [height, maxValue, minValue]);

  const xScale = useMemo(() => {
    return d3
      .scaleBand<string>()
      .domain(labels as Iterable<string>)
      .range([0, width]);
  }, [labels, width]);

  const handleOnMouseOver = useCallback(
    (e, barData: BarData) => {
      const { color, legend, value, label, percent, xAxisLabel } = barData;
      onMouseOver(e, {
        legend,
        value,
        color,
        label,
        percent,
        xAxisLabel,
      });

      setActiveBar(barData);
    },
    [onMouseOver]
  );

  const handleOnMouseOut = useCallback(
    (e) => {
      onMouseOut(e);
      setActiveBar(undefined);
    },
    [onMouseOut]
  );

  const handleOnMouseMove = useCallback(
    (e) => {
      onMouseMove(e);
    },
    [onMouseMove]
  );

  const handleOnClicked = useCallback(
    (
      e,
      barData: Omit<BarData, 'xAxisLabel' | 'percent'> & { label?: string }
    ) => {
      const { legend, label, value } = barData;
      barConfig?.onClick?.(e, {
        legend,
        label,
        data: value,
      });
    },
    [barConfig]
  );

  return data.length > 0 ? (
    <g>
      {series.map((subgroup) => {
        return (
          <g
            key={subgroup.key}
            transform={`translate(${Math.floor(
              xScale.bandwidth() / 2 - barMarginTop
            )},0)`}
          >
            {subgroup.map((group) => {
              const prevBarValue = group[0];
              const currentValue = group[1];

              if (Number.isNaN(prevBarValue) || Number.isNaN(currentValue)) {
                return null;
              }

              const { label } = group.data;

              const legend = subgroup.key;
              const { color } = data.filter((d) => d.label === legend)[0];
              const rectValue = Number(group.data.data[subgroup.key]);

              const rectY = Math.round(yScale(currentValue)); // round the position to avoid flaky

              const rectX = Math.round(xScale(label) || 0); // round the position to avoid flaky
              const isActive =
                typeof activeBar !== 'undefined'
                  ? isActiveBar(activeBar, { legend, label, rectValue })
                  : undefined;

              const barStartPositionY = yScale(prevBarValue);
              const barEndPositionY = yScale(currentValue);
              const hasMarginTop = prevBarValue === 0;

              const rectHeight = barEndPositionY - barStartPositionY;
              const barMargin = hasMarginTop ? 0 : barMarginTop;
              const rectHeightWithMargin =
                rectHeight === 0 ? 0 : rectHeight + barMargin;

              const total = Object.entries(group.data)
                .filter(([key]) => selectedLegends.includes(key))
                .reduce((acc, [_key, value]) => {
                  return acc + Number(value);
                }, 0);

              const totalValue = barConfig?.totalFormatter
                ? barConfig.totalFormatter(total)
                : total.toFixed(1);

              const textLength = totalValue.length;

              const svgLetterWidth = clamp(
                textLength * totalLetterWidth,
                totalLetterWidth,
                textLength * totalLetterWidth
              );

              const svgWidth = svgLetterWidth + totalSvgHorizontalPadding * 2;

              const totalX = rectX - svgWidth / 2 + 6;

              const isLastLegend =
                subgroup.key === selectedLegends[selectedLegends.length - 1];

              return (
                <>
                  <Rect
                    isHovered={isActive}
                    key={label + legend}
                    onMouseOver={(e) => {
                      handleOnMouseOver(e, {
                        legend: subgroup.key,
                        value: rectValue,
                        color,
                        label,
                        xAxisLabel: label,
                        percent: Math.round((rectValue / total) * 100),
                      });
                    }}
                    onMouseOut={handleOnMouseOut}
                    onMouseMove={handleOnMouseMove}
                    onClick={(e) => {
                      handleOnClicked(e, {
                        legend: subgroup.key,
                        value: rectValue,
                        color,
                        label,
                      });
                    }}
                    isHighlighted={matchedHighlightedItems(
                      {
                        legend,
                        label,
                      },
                      highlightedItems
                    )}
                    data-test-id={
                      dataTestId &&
                      `${dataTestId}-${label}-${legend}-${currentValue}`
                    }
                    color={color}
                    height={Math.abs(rectHeightWithMargin)}
                    x={rectX}
                    y={rectY}
                    cursor={barConfig?.onClick ? 'pointer' : 'default'}
                    size={size}
                  />
                  {barConfig?.showTotal && isLastLegend && (
                    <TotalBadge
                      content={totalValue}
                      x={totalX}
                      y={rectY - totalSvgHeight - barMarginTop}
                      width={svgWidth}
                      data-test-id={
                        dataTestId ? `${dataTestId}-total-badge` : undefined
                      }
                    />
                  )}
                </>
              );
            })}
          </g>
        );
      })}
    </g>
  ) : null;
};

export default BarArea;
