import React, {
  useCallback,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import * as d3 from 'd3';
import { useTheme } from 'styled-components';
import {
  StyledColumnChartContainer,
  StyledLegendContainer,
} from './StyledColumnChart';
import Typography from '../../Typography';

import { CommonProps } from '../../common';
import { useCss, useResizeObserver } from '../../../utils/hooks';
import {
  LegendConfig,
  MatchedSegment,
  NavigationConfig,
  Series,
  TickConfig,
  XAxisConfig,
  YAxisConfig,
  BarConfig,
  StyleConfig,
} from '../type';
import {
  difference,
  filterElementHasNoColor,
  totalOfMaxValuesFromEachRows,
  usePrevious,
} from '../utils';

import { useColorScale } from '../common/colorScale';
import { createNiceScale } from '../niceNumbers';
import BarArea from './ChartContent/BarArea';

import GridArea from './ChartContent/GridArea';
import LegendGroup from './ChartContent/LegendGroup';
import Navigation from './ChartContent/Navigation';
import YAxisTitle from './ChartContent/YAxisTitle';
import XAxis from './ChartContent/XAxis';
import YAxis from './ChartContent/YAxis';
import BarTooltip from './ChartContent/BarTooltip';

export const ColumnChartDataType = (props: Series<Array<number>>) => props;

type ElementSize = {
  height: number;
  width: number;
};

type DataValue = number | undefined;

export interface ColumnChartProps extends CommonProps {
  /**
   * Data of the chart.
   */
  data: Array<Series<Array<DataValue>>>;
  /**
   * Y axis config.
   */
  yAxisConfig?: Omit<YAxisConfig, 'labels'> & { tick?: TickConfig };
  /**
   * X axis config.
   */
  xAxisConfig?: Omit<XAxisConfig, 'maxValue' & 'step'>;
  /**
   * Legend config.
   */
  legendConfig?: LegendConfig;
  /**
   * Bar section config.
   */
  barConfig?: BarConfig<DataValue>;
  /**
   * Navigation button config.
   */
  navigationConfig?: NavigationConfig;
  /**
   * Matched pattern to highlight the bars.
   */
  highlightedItems?: MatchedSegment;
  /**
   * Tooltip renderer.
   */
  tooltipRenderer?: (props: {
    label?: string;
    value?: DataValue;
    legendColor?: string;
    xAxisLabel?: string;
  }) => React.ReactNode;
  /**
   * styleConfig use to custom the style of the chart.
   * * styleConfig must be an object:
   *    * color?: use to custom the legend colors.
   */
  styleConfig?: StyleConfig;
}

const ColumnChart = ({
  data,
  xAxisConfig,
  yAxisConfig,
  legendConfig,
  barConfig,
  'data-test-id': dataTestId,
  navigationConfig = { visible: false },
  style,
  className,
  id,
  sx,
  highlightedItems,
  tooltipRenderer: _tooltipRenderer,
  styleConfig,
}: ColumnChartProps) => {
  const niceValues = useMemo(() => {
    const maxDataValue = totalOfMaxValuesFromEachRows(data);
    const maxDataValuesWithShownTotal =
      typeof barConfig?.showTotal !== 'undefined'
        ? maxDataValue + 1
        : maxDataValue;
    return createNiceScale(0, maxDataValuesWithShownTotal);
  }, [barConfig?.showTotal, data]);

  const isNegativeBarChart = useMemo(
    () => data.some((d) => d.data.some((v) => v !== undefined && v < 0)),
    [data]
  );

  const maxValue = Number(yAxisConfig?.maxValue ?? niceValues.niceMax);
  const minValue = isNegativeBarChart ? -maxValue : 0;

  const step = yAxisConfig?.step || niceValues.tickSpacing;

  const tickInterval = yAxisConfig?.tick?.interval || step;

  const defaultBarSize = barConfig?.size || 'large';

  const theme = useTheme();

  const {
    __hd__: { columnChart: columnChartTheme },
  } = theme;

  const {
    columnChartMarginBottom,
    columnChartMarginLeft,
    columnChartMarginRight,
    columnChartMarginTop,
    columnChartMarginLeftWithNavigation,
    chartContentMarginLeft,
    navigationButtonMarginLeft,
  } = columnChartTheme.space;

  const chartMargin = {
    top: columnChartMarginTop,
    right: columnChartMarginRight,
    bottom: columnChartMarginBottom,
    left: yAxisConfig?.title
      ? columnChartMarginLeft
      : columnChartMarginLeftWithNavigation,
  };

  const axesRef = useRef(null);
  const tooltipRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const legendContainerRef = useRef<HTMLDivElement>(null);
  const barsContainerRef = useRef<SVGGElement>(null);
  const [containerSize, setContainerSize] = useState<ElementSize>({
    width: 0,
    height: 0,
  });
  const [legendContainerSize, setLegendContainerSize] = useState<ElementSize>({
    width: 0,
    height: 0,
  });

  const [internalSelectedLegends, setInternalSelectedLegends] = useState<
    string[]
  >([]);

  const svgSizes: ElementSize = useMemo(
    () => ({
      width: containerSize.width,
      height: containerSize.height - legendContainerSize.height,
    }),
    [containerSize.height, containerSize.width, legendContainerSize.height]
  );

  const [yAxisSize, setYAxisSize] = useState<ElementSize>({
    height: 0,
    width: 0,
  });

  const yAxisWidth = useMemo(
    () => Math.floor(yAxisSize.width),
    [yAxisSize.width]
  );

  const [yAxisTitleSize, setYAxisTitleSize] = useState<ElementSize>({
    height: 0,
    width: 0,
  });

  const yAxisTitleWidth = useMemo(
    () => Math.floor(yAxisTitleSize.width),
    [yAxisTitleSize.width]
  );

  const boundsWidth = svgSizes.width - chartMargin.right - chartMargin.left;

  const boundsHeight = svgSizes.height - chartMargin.top - chartMargin.bottom;

  const legends = useMemo(() => data.map((item) => item.label), [data]);

  const defaultLegends = useMemo(
    () =>
      legendConfig?.selectable
        ? legendConfig?.value || internalSelectedLegends
        : internalSelectedLegends,
    [internalSelectedLegends, legendConfig]
  );

  const selectedLegends = useMemo(
    () => legends.filter((l) => defaultLegends.includes(l)),
    [legends, defaultLegends]
  );

  const prevLegends = usePrevious(legends);

  const legendsDiff = useMemo(
    () => difference(legends, prevLegends || []),
    [legends, prevLegends]
  );

  const [currentSelectedBar, setCurrentSelectedBar] = useState<
    | {
        legend: string;
        value: number;
        legendColor: string;
        xAxisLabel: string;
        percent: string;
      }
    | undefined
  >(undefined);

  // Color Scale
  const colorScale = useColorScale(
    legends,
    styleConfig?.series !== undefined
      ? filterElementHasNoColor(styleConfig.series)
      : undefined
  );

  const resizeHandler = useCallback(() => {
    if (containerRef.current) {
      const { width, height } = containerRef.current.getBoundingClientRect();
      setContainerSize({ width, height });
    }
    if (legendContainerRef.current) {
      const { width, height } =
        legendContainerRef.current.getBoundingClientRect();
      setLegendContainerSize({ width, height });
    }
  }, []);

  const targetElement =
    containerRef.current?.parentElement !== undefined
      ? containerRef.current?.parentElement
      : null;

  useResizeObserver(resizeHandler, targetElement);

  useLayoutEffect(() => {
    setInternalSelectedLegends((prev) => {
      return Array.from(new Set([...prev, ...legendsDiff]));
    });
  }, [legendsDiff]);

  const onMouseOverBar = useCallback((_e, barData) => {
    const { color, legend, value, xAxisLabel, percent } = barData;
    setCurrentSelectedBar({
      legend,
      value,
      legendColor: color,
      xAxisLabel,
      percent,
    });
  }, []);

  const onMouseOutBar = useCallback(() => {
    setCurrentSelectedBar(undefined);
  }, []);

  const onMouseMoveBar = useCallback((e) => {
    const tooltipElement = d3.select(tooltipRef.current);
    const { clientX, clientY } = e;

    tooltipElement
      .style('top', `${clientY - 12}px`)
      .style('left', `${clientX}px`);
  }, []);

  const columnAreaData = useMemo(
    () =>
      data.map((d) => {
        return {
          ...d,
          color: colorScale(d.label),
        };
      }),
    [colorScale, data]
  );

  return (
    <StyledColumnChartContainer
      className={className}
      id={id}
      style={{ ...style, ...useCss({ ...sx }) }}
      data-test-id={dataTestId}
      ref={containerRef}
    >
      {navigationConfig.visible && (
        <Navigation
          top={boundsHeight / 2}
          left={
            yAxisConfig?.title
              ? chartContentMarginLeft - navigationButtonMarginLeft
              : 0
          }
          onClickNavigation={navigationConfig.onNavigate}
          data-test-id={dataTestId}
          disabledButtons={navigationConfig.disabledButtons}
        />
      )}

      <BarTooltip
        show={!!currentSelectedBar}
        data-test-id={dataTestId}
        ref={tooltipRef}
        color={currentSelectedBar?.legendColor}
        title={currentSelectedBar?.legend || ''}
        value={currentSelectedBar?.value}
        xAxisLabel={currentSelectedBar?.xAxisLabel}
        percent={currentSelectedBar?.percent}
        tooltipRenderer={_tooltipRenderer}
      />

      <svg width={svgSizes.width} height={svgSizes.height}>
        <g
          ref={barsContainerRef}
          transform={`translate(${yAxisWidth + chartMargin.left},${
            chartMargin.top
          }
          )`}
        >
          <YAxisTitle
            height={boundsHeight}
            setSize={setYAxisTitleSize}
            yAxisWidth={yAxisWidth}
            yAxisConfig={yAxisConfig}
          />
        </g>
        <g
          ref={axesRef}
          transform={`translate(${
            yAxisWidth + yAxisTitleWidth + chartContentMarginLeft
          },${chartMargin.top}
          )`}
        >
          <GridArea
            height={boundsHeight}
            width={boundsWidth}
            minValue={minValue}
            maxValue={maxValue}
            tickInterval={tickInterval}
            highlightMiddleLine={isNegativeBarChart}
            data-test-id={dataTestId ? `${dataTestId}-grid-line` : undefined}
          />
          <BarArea
            height={boundsHeight}
            width={boundsWidth}
            maxValue={maxValue}
            minValue={minValue}
            data-test-id={dataTestId}
            xAxisConfig={xAxisConfig}
            barConfig={barConfig}
            onMouseOver={onMouseOverBar}
            onMouseOut={onMouseOutBar}
            onMouseMove={onMouseMoveBar}
            highlightedItems={highlightedItems}
            selectedLegends={selectedLegends}
            data={columnAreaData}
            size={defaultBarSize}
          />

          <XAxis
            height={boundsHeight}
            width={boundsWidth}
            xAxisConfig={xAxisConfig}
            size={defaultBarSize}
          />
          <YAxis
            height={boundsHeight}
            maxValue={maxValue}
            minValue={minValue}
            getAxisSize={setYAxisSize}
            step={step}
          />
        </g>
      </svg>

      <StyledLegendContainer ref={legendContainerRef}>
        {!!xAxisConfig?.title && (
          <Typography.Text fontSize={12} fontWeight="regular" intent="subdued">
            {xAxisConfig.title}
          </Typography.Text>
        )}

        <LegendGroup
          legends={legends}
          onChange={setInternalSelectedLegends}
          selectedLegends={selectedLegends}
          data-test-id={dataTestId ? `${dataTestId}-legend` : undefined}
          legendConfig={legendConfig}
          colorScale={colorScale}
        />
      </StyledLegendContainer>
    </StyledColumnChartContainer>
  );
};

export default ColumnChart;
