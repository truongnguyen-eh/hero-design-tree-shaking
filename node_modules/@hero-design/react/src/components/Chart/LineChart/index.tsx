import React, { useCallback, useLayoutEffect, useMemo, useState } from 'react';
import {
  StyledLineChartContainer,
  StyledLegendContainer,
  StyledLineChartChildrenWrapper,
  StyledYAxisTitleAndNavigationButtonsAndChartContentWrapper,
} from './StyledLineChart';
import Typography from '../../Typography';

import { CommonProps } from '../../common';
import { useCss } from '../../../utils/hooks';
import { LegendConfig, NavigationConfig, Series, StyleConfig } from '../type';
import { difference, filterElementHasNoColor, usePrevious } from '../utils';
import LegendCheckboxGroup from '../Legend/LegendCheckboxGroup';
import LegendGroup from '../Legend/LegendGroup';
import ChartContent from './ChartContent';
import NavigationButtons from './NavigationButtons';
import YAxisTitle from './YAxisTitle';
import {
  DataValue,
  LineChartVariants,
  LineChartXAxisConfig,
  LineChartYAxisConfig,
} from './types';
import { useColorScale } from '../common/colorScale';

export const LineChartDataType = (props: Series<Array<number>>) => props;

export interface LineChartProps extends CommonProps {
  /**
   * Data of the chart.
   */
  data: Array<Series<Array<DataValue>>>;
  /**
   * Y axis config.
   */
  yAxisConfig?: LineChartYAxisConfig;
  /**
   * X axis config.
   */
  xAxisConfig?: LineChartXAxisConfig;
  /**
   * Legend config.
   */
  legendConfig?: LegendConfig;
  /**
   * Navigation button config.
   */
  navigationConfig?: NavigationConfig;
  /**
   * Chart variants.
   */
  variant?: LineChartVariants;
  /**
   * * styleConfig use to custom the style of the chart.
   * * styleConfig must be an object:
   *    * color?: use to custom the legend colors.
   */
  styleConfig?: StyleConfig;
}

const LineChart = ({
  data,
  xAxisConfig,
  yAxisConfig,
  legendConfig,
  'data-test-id': dataTestId,
  navigationConfig = { visible: false },
  style,
  className,
  id,
  sx,
  variant = 'outlined',
  styleConfig,
}: LineChartProps) => {
  const [internalSelectedLegends, setInternalSelectedLegends] = useState<
    string[]
  >([]);

  const legends = useMemo(() => data.map((item) => item.label), [data]);

  const selectedLegends = useMemo(
    () =>
      legendConfig?.selectable
        ? legendConfig?.value || internalSelectedLegends
        : internalSelectedLegends,
    [internalSelectedLegends, legendConfig]
  );

  const prevLegends = usePrevious(legends);

  const legendsDiff = useMemo(
    () => difference(legends, prevLegends || []),
    [legends, prevLegends]
  );

  const [currentSelectedLabel, setCurrentSelectedLabel] = useState<
    string | null
  >(null);

  const customColors = useMemo(
    () =>
      styleConfig?.series !== undefined
        ? filterElementHasNoColor(styleConfig.series)
        : undefined,
    [styleConfig?.series]
  );

  // Color Scale
  const colorScale = useColorScale(legends, customColors);

  useLayoutEffect(() => {
    setInternalSelectedLegends((prev) => {
      return Array.from(new Set([...prev, ...legendsDiff]));
    });
  }, [legendsDiff]);

  const renderLegend = () => {
    if (typeof legendConfig !== 'undefined') {
      if (legendConfig?.selectable) {
        return (
          <LegendCheckboxGroup
            data={legends}
            getDisplayText={(item) => item}
            getValue={(item) => item}
            getColor={(item) => colorScale(item)}
            value={selectedLegends}
            onChange={setInternalSelectedLegends}
            data-test-id={
              dataTestId ? `${dataTestId}-checkbox-legend` : undefined
            }
            {...legendConfig}
          />
        );
      }
      return (
        <LegendGroup
          data={legends}
          getDisplayText={(item) => item}
          getColor={(item) => colorScale(item)}
          data-test-id={dataTestId ? `${dataTestId}-legend` : undefined}
          {...legendConfig}
        />
      );
    }
    return null;
  };

  const filteredData = data.filter((item) => {
    return selectedLegends.includes(item.label);
  });

  const onMouseOverSeriesHanlder = useCallback(
    (_e: React.MouseEvent<SVGElement>, label: string) => {
      setCurrentSelectedLabel(label);
    },
    []
  );

  const onMouseOutSeriesHanlder = useCallback(
    (_e: React.MouseEvent<SVGElement>, _label: string) => {
      setCurrentSelectedLabel(null);
    },
    []
  );

  return (
    <StyledLineChartContainer
      className={className}
      id={id}
      style={{ ...style, ...useCss({ ...sx }) }}
      data-test-id={dataTestId}
    >
      <StyledLineChartChildrenWrapper data-test-id="chart-children-wrapper">
        <StyledYAxisTitleAndNavigationButtonsAndChartContentWrapper data-test-id="chart-1">
          {!!yAxisConfig?.title && <YAxisTitle title={yAxisConfig.title} />}
          <NavigationButtons
            visible={navigationConfig.visible}
            data-test-id={dataTestId}
            onNavigate={navigationConfig.onNavigate}
            disabledButtons={navigationConfig.disabledButtons}
          >
            <ChartContent
              data-test-id="line-chart-content"
              onMouseOutSeriesLine={onMouseOutSeriesHanlder}
              onMouseOverSeriesLine={onMouseOverSeriesHanlder}
              xAxisConfig={xAxisConfig}
              yAxisConfig={yAxisConfig}
              chartVariant={variant}
              data={filteredData.map((item) => ({
                data: item.data,
                color: colorScale(item.label),
                label: item.label,
                isHighlighted:
                  !!item.label && currentSelectedLabel === item.label,
              }))}
            />
          </NavigationButtons>
        </StyledYAxisTitleAndNavigationButtonsAndChartContentWrapper>
        <StyledLegendContainer>
          {!!xAxisConfig?.title && (
            <Typography.Text
              fontSize={12}
              fontWeight="regular"
              intent="subdued"
            >
              {xAxisConfig.title}
            </Typography.Text>
          )}
          {renderLegend()}
        </StyledLegendContainer>
      </StyledLineChartChildrenWrapper>
    </StyledLineChartContainer>
  );
};

export default LineChart;
