import React, { memo } from 'react';
import { useTheme } from 'styled-components';
import { CommonProps } from '../../../common';

export type Point = {
  x: number;
  y: number;
};

export type LineType = 'highlighted' | 'default' | 'no-highlighted';

interface SeriesLineProps extends CommonProps {
  /**
   * series label of the line.
   */
  label: string;
  /**
   * Array of points to draw the line.
   */
  points: Point[];
  /**
   * line color.
   */
  color: string;
  /**
   * Type of line.
   */
  type?: LineType;
  /**
   * Width of draw area.
   */
  width: number;
  /**
   * Height of draw area.
   */
  height: number;
  /**
   * Indicate to fill the area under the line.
   * */
  isFillColor?: boolean;
  /**
   * Callback function that is fired when the mouse enters the element.
   */
  onMouseOut?: (event: React.MouseEvent<SVGElement>, label: string) => void;
  /**
   * Callback function that is fired when the mouse leaves the element.
   */
  onMouseMove?: (event: React.MouseEvent<SVGElement>, label: string) => void;
  /**
   * Callback function that is fired when the mouse moves over the element.
   */
  onMouseOver?: (event: React.MouseEvent<SVGElement>, label: string) => void;
}

export const convertPointsToFillPath = (points: Point[], height: number) => {
  const path = points.reduce((acc, point, index) => {
    if (index === 0) {
      return `M ${point.x} ${point.y}`;
    }
    return `${acc} L ${point.x} ${point.y}`;
  }, '');
  return `${path} V ${height} H 0 Z`;
};

const StrokeLine = ({
  points,
  'data-test-id': dataTestID,
  color,
  type,
}: {
  points: Point[];
  color: string;
  type: LineType;
  'data-test-id'?: string;
}) => {
  const { lineChart } = useTheme().__hd__;
  return (
    <g data-test-id={dataTestID}>
      {points.map((point, index) => {
        if (index === points.length - 1) {
          return null;
        }
        const nextPoint = points[index + 1];
        const testId = `${dataTestID}-${index}`;
        const key = `${point.x}-${point.y}-${nextPoint.x}-${nextPoint.y}`;
        switch (type) {
          case 'default':
            return (
              <line
                key={key}
                data-test-id={testId}
                x1={point.x}
                y1={point.y}
                x2={nextPoint.x}
                y2={nextPoint.y}
                cursor="pointer"
                stroke={color}
                strokeWidth={lineChart.borderWidth.line.default}
              />
            );
          case 'highlighted':
            return (
              <line
                key={key}
                data-test-id={testId}
                x1={point.x}
                y1={point.y}
                x2={nextPoint.x}
                y2={nextPoint.y}
                cursor="pointer"
                stroke={color}
                strokeWidth={lineChart.borderWidth.line.highlighted}
              />
            );
          case 'no-highlighted':
            return (
              <line
                key={key}
                data-test-id={testId}
                x1={point.x}
                y1={point.y}
                x2={nextPoint.x}
                y2={nextPoint.y}
                cursor="pointer"
                strokeDasharray={lineChart.strokeDasharray.line}
                stroke={color}
                strokeWidth={lineChart.borderWidth.line.noHighlighted}
              />
            );

          default:
            return null;
        }
      })}
    </g>
  );
};

// this component renders a line between the points of a serie
const SeriesLine = memo(
  ({
    'data-test-id': dataTestId,
    color,
    label,
    points,
    type = 'default',
    onMouseOver: _onMouseOver,
    onMouseOut: _onMouseOut,
    onMouseMove: _onMouseMove,
    width,
    height,
    isFillColor = false,
  }: SeriesLineProps) => {
    const onMouseOver = React.useCallback(
      (e: React.MouseEvent<SVGElement>) => {
        if (_onMouseOver) {
          _onMouseOver(e, label);
        }
      },
      [_onMouseOver, label]
    );

    const onMouseOut = React.useCallback(
      (e) => {
        if (_onMouseOut) {
          _onMouseOut(e, label);
        }
      },
      [_onMouseOut, label]
    );

    const onMouseMove = React.useCallback(
      (e) => {
        if (_onMouseMove) {
          _onMouseMove(e, label);
        }
      },
      [_onMouseMove, label]
    );

    // draw SVGElement path from points
    const fillPath = React.useMemo(() => {
      return convertPointsToFillPath(points, height);
    }, [height, points]);

    const svgID = label.replace(/\s/g, '') + color;
    const lineDataTestId = `${dataTestId ?? 'seriesline'}`;

    return (
      <g
        data-test-id={dataTestId}
        key={label}
        onMouseOver={onMouseOver}
        onMouseOut={onMouseOut}
        onMouseMove={onMouseMove}
      >
        {isFillColor && (
          <>
            <path
              pointerEvents="none"
              d={fillPath}
              stroke="none"
              fill={`url(#paint0_linear_${svgID})`}
              data-test-id={`${lineDataTestId}-fill-path`}
            />
            <defs>
              <linearGradient
                id={`paint0_linear_${svgID}`}
                x1={width}
                y1="0"
                x2={width}
                y2={height}
                gradientUnits="userSpaceOnUse"
              >
                <stop stopColor={color} stopOpacity="0.5" />
                <stop offset="1" stopColor={color} stopOpacity="0" />
              </linearGradient>
            </defs>
          </>
        )}
        <StrokeLine
          points={points}
          color={color}
          type={type}
          data-test-id={`${lineDataTestId}-stroke-line`}
        />
      </g>
    );
  }
);

export default SeriesLine;
