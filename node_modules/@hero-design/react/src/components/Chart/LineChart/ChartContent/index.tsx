import React, {
  memo,
  useMemo,
  useRef,
  useState,
  useCallback,
  useLayoutEffect,
} from 'react';
import { useTheme } from 'styled-components';
import * as d3 from 'd3';
import { CommonProps } from '../../../common';
import SeriesLines from './SeriesLines';
import XAxisGrid from './XAxisGrid';
import YAxisGrid from './YAxisGrid';
import { debounce } from '../../../../utils/debounce';
import XAxis from './XAxis';
import YAxis from './YAxis';
import {
  DataValue,
  ElementSize,
  LineChartXAxisConfig,
  LineChartYAxisConfig,
  LineChartVariants,
} from '../types';
import { StyledChartContentWrapper } from './StyledChartContent';
import { StyledTooltipContentWrapper } from '../StyledLineChart';
import { Point } from './SeriesLine';
import { StyledTooltip } from '../../StyledChart';
import HighlightCircle from './HighlightCircle';
import TooltipContent from './TooltipContent';
import { createNiceScale } from '../../niceNumbers';
import { useResizeObserver } from '../../../../utils/hooks';
import { getParentElement } from '../../utils';

const isNull = (value: DataValue) => value == null && value === undefined;

const filterNullValues = (data: DataValue[]): number[] => {
  return data.filter((d): d is number => !isNull(d));
};

export const maxValueFromDataSet = (
  data: Array<{
    data: DataValue[];
  }>
) => {
  return data.reduce((acc, curr) => {
    const max = Math.max(...filterNullValues(curr.data));
    return max > acc ? max : acc;
  }, 0);
};

export const minValueFromDataSet = (
  data: Array<{
    data: DataValue[];
  }>
) => {
  return data.reduce((acc, curr) => {
    const min = Math.min(...filterNullValues(curr.data));
    return min < acc ? min : acc;
  }, 0);
};

const convertDataToSeriesLinesPoints = (
  data: Array<{
    data: DataValue[];
    color: string;
    label: string;
    isHighlighted: boolean;
  }>,
  width: number,
  height: number,
  minValue: number,
  maxValue: number,
  labels: string[]
) => {
  const xScale = d3.scalePoint<string>(labels, [0, width]).align(0);

  const yScale = d3
    .scaleLinear()
    .domain([minValue, maxValue])
    .range([height, 0]);

  return data.map((item) => ({
    points: item.data.map((d, index) => ({
      x: xScale(labels[index]) ?? 0,
      y: yScale(d ?? 0) ?? 0,
    })),
    color: item.color,
    label: item.label,
    isHighlighted: item.isHighlighted,
  }));
};

interface ChartContentProps extends CommonProps {
  /**
   * Y axis config.
   */
  yAxisConfig?: LineChartYAxisConfig;
  /**
   * X axis config.
   */
  xAxisConfig?: LineChartXAxisConfig;
  /**
   * data for line chart.
   * */
  data: Array<{
    data: DataValue[];
    color: string;
    label: string;
    isHighlighted: boolean;
  }>;
  /**
   * mouse out handler.
   * */
  onMouseOutSeriesLine?: (
    event: React.MouseEvent<SVGElement>,
    label: string
  ) => void;
  /**
   * mouse over handler.
   * */
  onMouseOverSeriesLine?: (
    event: React.MouseEvent<SVGElement>,
    label: string
  ) => void;
  /**
   * mouse over handler.
   * */
  onMouseMoveSeriesLine?: (
    event: React.MouseEvent<SVGElement>,
    label: string
  ) => void;
  /**
   * Chart variant.
   * */
  chartVariant?: LineChartVariants;
}

const ChartContent = ({
  'data-test-id': dataTestId,
  xAxisConfig,
  yAxisConfig,
  data,
  onMouseOutSeriesLine: _onMouseOutSeriesLine,
  onMouseOverSeriesLine: _onMouseOverSeriesLine,
  onMouseMoveSeriesLine: _onMouseMoveSeriesLine,
  chartVariant = 'outlined',
}: ChartContentProps) => {
  const lineChartTheme = useTheme().__hd__.lineChart;

  const [size, setSize] = useState<ElementSize>({ width: 0, height: 0 });
  const ref = useRef<HTMLDivElement>(null);

  const { yAxisWidth } = lineChartTheme.sizes;
  const { xAxisHeight } = lineChartTheme.sizes;
  // Render the X and Y axis using d3.js, not react
  const seriesLinesRect = {
    x: yAxisWidth,
    width: size.width - yAxisWidth,
    y: 0,
    height: size.height - xAxisHeight,
  };

  const resizeHandler = useCallback(
    debounce(() => {
      if (ref.current) {
        const { width, height } = ref.current.getBoundingClientRect();
        setSize({ width, height });
      }
    }, 30),
    []
  );

  useLayoutEffect(() => {
    resizeHandler();
  }, [resizeHandler]);

  // handle resize
  useResizeObserver(resizeHandler, getParentElement(ref.current));

  const niceValues = useMemo(() => {
    const maxDataValue = maxValueFromDataSet(data);
    const minDataValue = minValueFromDataSet(data);
    return createNiceScale(minDataValue, maxDataValue);
  }, [data]);
  // If the user has provided a min/max value, use that instead of the min/max value from the data
  const yMaxValue = yAxisConfig?.maxValue ?? niceValues.niceMax;
  const yMinValue = yAxisConfig?.minValue ?? niceValues.niceMin;
  // If the user has provided a number of steps, use that instead of the tick spacing calculated by nice numbers algorithm
  const yAxisStep = yAxisConfig?.step ?? niceValues.tickSpacing;
  // If the user has provided a number of intervals, use that instead of the same number as the number of steps
  const yAxisInterval = yAxisConfig?.tick?.interval ?? yAxisStep;

  const seriesLinesData = useMemo(
    () =>
      convertDataToSeriesLinesPoints(
        data,
        seriesLinesRect.width,
        seriesLinesRect.height,
        yMinValue,
        yMaxValue,
        xAxisConfig?.labels ?? []
      ),

    [
      data,
      seriesLinesRect.height,
      seriesLinesRect.width,
      yMinValue,
      yMaxValue,
      xAxisConfig?.labels,
    ]
  );

  const [tooltipData, setTooltipData] = useState<{
    point: Point;
    label: string;
    value: DataValue;
    color: string;
  } | null>(null);

  const onMouseOverSeriesHanlder = useCallback(
    (e: React.MouseEvent<SVGElement>, label: string) => {
      if (_onMouseOverSeriesLine) {
        _onMouseOverSeriesLine(e, label);
      }
    },
    [_onMouseOverSeriesLine]
  );

  const onMouseOutSeriesHanlder = useCallback(
    (e: React.MouseEvent<SVGElement>, label: string) => {
      if (_onMouseOutSeriesLine) {
        _onMouseOutSeriesLine(e, label);
      }
      setTooltipData(null);
    },
    [_onMouseOutSeriesLine]
  );

  const onMouseMoveSeriesHanlder = useCallback(
    (e: React.MouseEvent<SVGElement>, label: string) => {
      if (_onMouseMoveSeriesLine) {
        _onMouseMoveSeriesLine(e, label);
      }

      // convert event coordinates to svg coordinates
      const svg = e.currentTarget.closest('svg');
      if (!svg) {
        return;
      }
      const pt = svg.createSVGPoint();
      pt.x = e.clientX;
      pt.y = e.clientY;
      const position = pt.matrixTransform(svg.getScreenCTM()?.inverse());

      const numbersOfLabels = xAxisConfig?.labels?.length ?? 0;
      // how to convert x to label
      const xScale = d3
        .scaleLinear()
        .domain([0, seriesLinesRect.width])
        .range([0, numbersOfLabels - 1]);

      const labelIndex = Math.round(xScale(position.x));

      const highlightedSeriesLineData = seriesLinesData.find(
        (d) => d.label === label
      );

      if (!highlightedSeriesLineData) {
        setTooltipData(null);
        return;
      }

      const point = highlightedSeriesLineData.points[labelIndex];
      const lineColor = highlightedSeriesLineData.color;
      const value = data.find((d) => d.label === label)?.data[labelIndex];
      if (point) {
        setTooltipData({
          point: {
            x: point.x,
            y: point.y,
          },
          label,
          value,
          color: lineColor,
        });
      }
    },
    [
      seriesLinesRect.width,
      xAxisConfig?.labels,
      seriesLinesData,
      data,
      _onMouseMoveSeriesLine,
    ]
  );

  const tooltipPosition = tooltipData
    ? {
        x: tooltipData.point.x + seriesLinesRect.x,
        y:
          tooltipData.point.y +
          seriesLinesRect.y -
          lineChartTheme.space.tooltipBottomMargin,
      }
    : null;

  return (
    <StyledChartContentWrapper ref={ref} data-test-id={dataTestId}>
      {size.width > 0 && size.height > 0 && (
        <svg
          data-test-id={`${dataTestId}-svg`}
          width={size.width}
          height={size.height}
          overflow="visible"
        >
          <g>
            <g
              transform={`translate(${seriesLinesRect.x},${seriesLinesRect.y})`}
            >
              <YAxisGrid
                maxValue={yMaxValue}
                minValue={yMinValue}
                interval={yAxisInterval}
                width={seriesLinesRect.width}
                height={seriesLinesRect.height}
              />
              <XAxisGrid
                xAxisConfig={xAxisConfig}
                width={seriesLinesRect.width}
                height={seriesLinesRect.height}
              />
              <XAxis
                xAxisConfig={xAxisConfig}
                width={seriesLinesRect.width}
                height={seriesLinesRect.height}
              />
              <SeriesLines
                isFillColor={chartVariant === 'filled'}
                width={seriesLinesRect.width}
                height={seriesLinesRect.height}
                seriesLinesData={seriesLinesData}
                onMouseOut={onMouseOutSeriesHanlder}
                onMouseOver={onMouseOverSeriesHanlder}
                onMouseMove={onMouseMoveSeriesHanlder}
                data-test-id={`${dataTestId}-series-lines`}
              />
              <HighlightCircle
                display={tooltipData?.point ? 'block' : 'none'}
                cx={tooltipData?.point.x}
                cy={tooltipData?.point?.y}
                color={tooltipData?.color}
              />
            </g>
            <YAxis
              maxValue={yMaxValue}
              minValue={yMinValue}
              step={yAxisStep}
              height={seriesLinesRect.height}
              width={yAxisWidth}
            />
          </g>
        </svg>
      )}
      <StyledTooltip
        style={{
          display: tooltipPosition ? 'block' : 'none',
          top: tooltipPosition?.y,
          left: tooltipPosition?.x,
          pointerEvents: 'none',
          transform: 'translate(0, -100%)',
        }}
        data-test-id={`${dataTestId}-tooltip`}
        variant="light"
      >
        <StyledTooltipContentWrapper>
          <TooltipContent
            label={tooltipData?.label}
            value={tooltipData?.value}
            legendColor={tooltipData?.color}
          />
        </StyledTooltipContentWrapper>
      </StyledTooltip>
    </StyledChartContentWrapper>
  );
};

export default memo(ChartContent);
