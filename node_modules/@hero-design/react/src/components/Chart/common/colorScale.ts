import * as d3 from 'd3';
import { useTheme } from 'styled-components';
import { useMemo } from 'react';
import { Theme } from '../../../theme';

import { Palette } from '../../../theme/global/colors';
import { ChartColor, chartColors } from '../constants';
import assert from '../../../utils/assert';
import { contains } from '../utils';

export const getColorFromTheme = (
  semanticColor: keyof Palette,
  theme: Theme
) => {
  return theme.colors.palette[semanticColor] || semanticColor;
};

export const COLOR_MESSAGE_ERROR =
  'styleConfig.series should have enough color for all labels';

// Color Scale
export const useColorScale = (
  labels: string[],
  customColors?: Array<{
    label: string;
    color: ChartColor;
  }>
) => {
  const theme = useTheme();

  const hasCustomColors = customColors !== undefined;

  const defaultColors = useMemo(
    () =>
      chartColors
        .slice(0, labels.length)
        .map((c) => getColorFromTheme(c, theme)),
    [labels.length, theme]
  );

  const customLabels = useMemo(
    () => (hasCustomColors ? customColors.map(({ label }) => label) : []),
    [customColors, hasCustomColors]
  );

  if (hasCustomColors) {
    // Throw error if user is incomplete fill label for the series.
    assert(
      customLabels.length >= labels.length &&
        contains(customLabels, labels) &&
        customLabels.length > 0,
      COLOR_MESSAGE_ERROR
    );
  }

  const customColorsFromTheme = useMemo(
    () =>
      hasCustomColors
        ? customColors.map(({ color }) => getColorFromTheme(color, theme))
        : [],
    [customColors, hasCustomColors, theme]
  );

  return useMemo(() => {
    return d3
      .scaleOrdinal<string>()
      .domain((hasCustomColors ? customLabels : labels) as Iterable<string>)
      .range(hasCustomColors ? customColorsFromTheme : defaultColors);
  }, [
    customColorsFromTheme,
    customLabels,
    defaultColors,
    hasCustomColors,
    labels,
  ]);
};
