import React, { useCallback, useMemo, useState } from 'react';
import * as d3 from 'd3';
import { useTheme } from 'styled-components';
import Rect from './Rect';
import { BarConfig, MatchedSegment, Series, YAxisConfig } from '../../type';
import { CommonProps } from '../../../common';
import { DataValue } from '../../LineChart/types';
import { clamp } from '../../utils';

type BarData = {
  legend: string;
  value: number;
  color: string;
  label: string;
};

interface BarAreaProps extends CommonProps {
  width: number;
  height: number;
  maxValue: number;
  minValue: number;
  yAxisConfig?: Omit<YAxisConfig, 'maxValue'>;
  highlightedItems?: MatchedSegment;
  barConfig?: Omit<BarConfig<DataValue>, 'showTotal'>;
  onMouseOver: (e: PointerEvent, barData: BarData) => void;
  onMouseOut: (e: PointerEvent) => void;
  onMouseMove: (e: PointerEvent) => void;
  selectedLegends: string[];
  data: Array<Series<Array<DataValue>> & { color: string }>;
  isNegative: boolean;
  barSize?: BarConfig<DataValue>['size'];
}

const BarArea = ({
  yAxisConfig,
  height,
  width,
  maxValue,
  minValue,
  'data-test-id': dataTestId,
  highlightedItems,
  barConfig,
  onMouseOver,
  selectedLegends,
  data,
  onMouseOut,
  onMouseMove,
  isNegative,
  barSize = 'large',
}: BarAreaProps) => {
  const theme = useTheme();

  const {
    __hd__: { horizontalBarChart: horizontalBarChartTheme },
  } = theme;

  const { barHeight: barHeightMapping } = horizontalBarChartTheme.sizes;

  const barHeight = barHeightMapping[barSize];

  const { bar: barBorderRadiusMapping } = horizontalBarChartTheme.radii;

  const barBorderRadius = barBorderRadiusMapping[barSize];

  const { horizontalBarMarginLeft, horizontalBarMarginTop } =
    horizontalBarChartTheme.space;

  const labels = useMemo(
    () => yAxisConfig?.labels || [],
    [yAxisConfig?.labels]
  );

  const [activeBar, setActiveBar] = useState<BarData | undefined>(undefined);

  const stackSeries = useMemo(
    () =>
      d3
        .stack()
        .keys(selectedLegends)
        .order(d3.stackOrderNone)
        .offset(d3.stackOffsetNone),
    [selectedLegends]
  );

  const series = useMemo(
    () =>
      stackSeries(
        labels.map((label, index) => {
          const stackedSeries = data.reduce((prev, next) => {
            return {
              ...prev,
              [next.label]: next.data[index],
            };
          }, {});
          return {
            ...stackedSeries,
            label,
          };
        }) as Iterable<{ [key: string]: number }>
      ),
    [data, labels, stackSeries]
  );

  const yScale = useMemo(() => {
    return d3
      .scaleBand<string>()
      .domain(labels as Iterable<string>)
      .range([0, height]);
  }, [labels, height]);

  const xScale = useMemo(() => {
    return d3.scaleLinear().domain([minValue, maxValue]).range([0, width]);
  }, [minValue, maxValue, width]);

  const matchedHighlightedItems = useCallback(
    ({ legend, label }: { legend?: string; label?: string }) => {
      if (typeof highlightedItems === 'undefined') return undefined;
      const isMatchedSegmentNotEmpty =
        typeof highlightedItems !== 'undefined'
          ? highlightedItems.length > 0
          : false;
      if (isMatchedSegmentNotEmpty) {
        return (
          highlightedItems &&
          highlightedItems.filter(
            (item) => item.label === label && item.legend === legend
          ).length > 0
        );
      }
      return false;
    },
    [highlightedItems]
  );

  const handleOnMouseOver = useCallback(
    (e, barData: BarData) => {
      const { color, legend, value, label } = barData;
      onMouseOver(e, {
        legend,
        value,
        color,
        label,
      });

      setActiveBar(barData);
    },
    [onMouseOver]
  );

  const handleOnMouseOut = useCallback(
    (e) => {
      onMouseOut(e);
      setActiveBar(undefined);
    },
    [onMouseOut]
  );

  const handleOnMouseMove = useCallback(
    (e) => {
      onMouseMove(e);
    },
    [onMouseMove]
  );

  const handleOnClicked = useCallback(
    (e, barData: BarData & { label?: string }) => {
      const { legend, label, value } = barData;
      barConfig?.onClick?.(e, {
        legend,
        label,
        data: value,
      });
    },
    [barConfig]
  );

  return (
    <g>
      {series.map((subgroup, index) => {
        return (
          <g
            key={subgroup.key}
            transform={`translate(0, ${Math.floor(
              yScale.bandwidth() / 2 - horizontalBarMarginLeft
            )})`}
          >
            {subgroup.map((group) => {
              const prevBarValue = group[0];
              const currentValue = group[1];

              const defaultPositionX = xScale(0);
              const barStartPositionX = xScale(prevBarValue);
              const barEndPositionX = xScale(currentValue);

              const barStartPositionY = yScale(group.data.label.toString());

              const recWidth = barEndPositionX - barStartPositionX;
              const rectX =
                recWidth < 0
                  ? Math.abs(defaultPositionX) - Math.abs(recWidth)
                  : Math.abs(defaultPositionX);

              const x = isNegative ? rectX : defaultPositionX;

              const rectY =
                (barStartPositionY || 0) +
                index * (barHeight + horizontalBarMarginTop);

              const radius = clamp(
                width / 2.5,
                barBorderRadiusMapping.inactive,
                barBorderRadius
              );
              const legend = subgroup.key;

              const { color } = data.filter((d) => d.label === legend)[0];
              const rectValue = group.data[subgroup.key];
              const { label } = group.data;

              const isActive =
                typeof activeBar !== 'undefined'
                  ? activeBar?.legend === legend &&
                    activeBar.value === rectValue &&
                    activeBar.color === color &&
                    activeBar.label === label.toString()
                  : undefined;

              return !(
                Number.isNaN(prevBarValue) || Number.isNaN(currentValue)
              ) ? (
                <Rect
                  active={isActive}
                  key={label + legend}
                  onMouseOver={(e) => {
                    handleOnMouseOver(e, {
                      legend: subgroup.key,
                      value: rectValue,
                      color,
                      label: label.toString(),
                    });
                  }}
                  onMouseOut={handleOnMouseOut}
                  onMouseMove={handleOnMouseMove}
                  onClick={(e) => {
                    if (typeof rectValue !== 'number') return;
                    handleOnClicked(e, {
                      legend: subgroup.key,
                      value: rectValue,
                      color,
                      label: label.toString(),
                    });
                  }}
                  isHighlighted={matchedHighlightedItems({
                    legend,
                    label: label.toString(),
                  })}
                  className="bars"
                  data-test-id={
                    dataTestId && dataTestId + label + legend + currentValue
                  }
                  color={color}
                  width={Math.abs(recWidth)}
                  x={x}
                  y={rectY}
                  radius={radius}
                  size={barSize}
                />
              ) : null;
            })}
          </g>
        );
      })}
    </g>
  );
};

export default BarArea;
