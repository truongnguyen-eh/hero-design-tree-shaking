import React, { useEffect, useMemo, useRef, useState } from 'react';
import { pie, arc, select, PieArcDatum, local as d3local } from 'd3';
import { useTheme, type DefaultTheme } from 'styled-components';
import {
  StyledChartContainer,
  StyledIconContainer,
  StyledInnerContentContainer,
  StyledPieChartContainer,
} from './StyledPieChart';
import { CommonProps } from '../../common';
import { useCss } from '../../../utils/hooks';
import Typography from '../../Typography';
import Box from '../../Box';
import { ChartColor, chartColors } from '../constants';
import Icon, { IconName } from '../../Icon';
import { StyledLegendDot } from '../Legend/StyledLegend';
import {
  StyledChartTitle,
  StyledTitleContainer,
  StyledTooltip,
} from '../StyledChart';
import { ItemConfig, LegendConfig, Series, StyleConfig } from '../type';
import LegendCheckboxGroup from '../Legend/LegendCheckboxGroup';
import LegendGroup from '../Legend/LegendGroup';
import { difference, filterElementHasNoColor, usePrevious } from '../utils';
import { useColorScale } from '../common/colorScale';

export interface PieChartProps extends CommonProps {
  /**
   * Data to be displayed in pie chart.
   */
  data: Array<
    Series<
      | number
      | {
          value: number;
          icon?: IconName;
        }
    >
  >;
  /**
   * Size of chart.
   */
  size?: 'small' | 'medium' | 'large';
  /**
   * Title of chart.
   */
  title?: string;
  /**
   * Legend configuration.
   */
  legendConfig?: LegendConfig;
  /**
   * onClick handler.
   */
  onClick?: (e: PointerEvent, value: PieChartProps['data'][number]) => void;
  /**
   * Alway show total inside pie chart.
   */
  alwaysShowTotal?: boolean;
  /**
   * Matched pattern to highlight the slice.
   */
  highlightedItems?: string[];
  /**
   * Total number formatter.
   */
  totalFormatter?: (value: number) => string;
  /**
   * Total display text.
   */
  totalText?: string;
  /**
   * * styleConfig use to custom the style of the chart.
   * * styleConfig must be an object:
   *    * color?: use to custom the legend colors.
   */
  styleConfig?: StyleConfig;
  /**
   * Custom renderrer for central content inside the chart.
   */
  centralContentRenderer?: () => React.ReactNode;
  /**
   * * itemConfig use to custom the slice of the pie chart.
   */
  itemConfig?: ItemConfig<
    Series<
      | number
      | {
          value: number;
          icon?: IconName;
        }
    >
  >;
}

interface InternalChartData {
  name: string;
  value: number;
  icon?: IconName;
  color: ChartColor;
  originalData: Series<
    | number
    | {
        value: number;
        icon?: IconName;
      }
  >;
}

const getDiametterFromSize = (
  size: 'small' | 'medium' | 'large',
  theme: DefaultTheme
) => {
  return theme.__hd__.chart.sizes.pie[size];
};

const getStrokeWidth = (
  size: 'small' | 'medium' | 'large',
  theme: DefaultTheme
) => {
  return theme.__hd__.chart.sizes.pie.stokes[size];
};

const getHoverStrokeWidth = (
  size: 'small' | 'medium' | 'large',
  theme: DefaultTheme
) => {
  return theme.__hd__.chart.sizes.pie.hoverStrokes[size];
};

const getRestHoverStrokeWidth = (
  size: 'small' | 'medium' | 'large',
  theme: DefaultTheme
) => {
  return theme.__hd__.chart.sizes.pie.restHoverStrokes[size];
};

const getTitleLevel = (size: 'small' | 'medium' | 'large') =>
  size === 'small' ? 5 : 3;

const ANGLE_PADDING = Math.PI / 12;

const PieChart = ({
  data: originalData,
  size = 'medium',
  sx = {},
  style,
  'data-test-id': dataTestId,
  className,
  legendConfig,
  title,
  id,
  onClick,
  alwaysShowTotal = false,
  highlightedItems,
  totalText = 'Total',
  totalFormatter = (value) => value.toString(),
  styleConfig,
  centralContentRenderer,
  itemConfig,
}: PieChartProps) => {
  const matchedSegmentByLabel = useMemo(() => {
    return highlightedItems?.reduce((acc: { [key: string]: boolean }, item) => {
      acc[item] = true;
      return acc;
    }, {});
  }, [highlightedItems]);

  const [currentIndex, setCurrentIndex] = useState<number | undefined>(
    undefined
  );

  const theme = useTheme();
  const diametter = getDiametterFromSize(size, theme);

  const chartSize = diametter + theme.__hd__.chart.spaces.pie.padding;
  const radius = diametter / 2;
  const strokeWidth = getStrokeWidth(size, theme);

  const hoverStrokeWidth = getHoverStrokeWidth(size, theme);

  const restHoverStrokeWidth = getRestHoverStrokeWidth(size, theme);

  const strokeSizeDiff = (strokeWidth - restHoverStrokeWidth) / 2;

  const { colors } = theme;

  const { sliceGap } = theme.__hd__.chart.spaces.pie;

  const tooltipRef = useRef(null);
  const svgRef = useRef(null);

  const [internalSelectedLegends, setInternalSelectedLegends] = useState<
    string[]
  >([]);

  const selectedLegends = useMemo(
    () =>
      legendConfig?.selectable
        ? legendConfig?.value || internalSelectedLegends
        : internalSelectedLegends,
    [internalSelectedLegends, legendConfig]
  );

  const selectedLegendByName = useMemo(
    () =>
      selectedLegends.reduce((acc: { [key: string]: boolean }, legend) => {
        acc[legend] = true;
        return acc;
      }, {}),
    [selectedLegends]
  );

  const data: InternalChartData[] = useMemo(
    () =>
      originalData
        .map((item, index) => ({
          name: item.label,
          value: typeof item.data === 'number' ? item.data : item.data?.value,
          icon: typeof item.data === 'number' ? undefined : item.data?.icon,
          color: chartColors[index],
          originalData: item,
        }))
        .filter((item) => !!selectedLegendByName[item.name]),
    [originalData, selectedLegendByName]
  );

  const total = data?.reduce((acc, item) => acc + (item?.value ?? 0), 0);

  const minValue = useMemo(
    () => Math.min(...(data?.map((item) => item.value) || [])),
    [data]
  );

  const minPercentage = (minValue / total) * 100;

  const customColors = useMemo(
    () =>
      styleConfig?.series !== undefined
        ? filterElementHasNoColor(styleConfig.series)
        : undefined,
    [styleConfig?.series]
  );

  const colorScale = useColorScale(
    originalData.map((item) => item.label),
    customColors
  );
  const pieGenerator = useMemo(
    () =>
      pie<InternalChartData>()
        .startAngle(0)
        .padAngle(minPercentage < 5 ? ANGLE_PADDING : 0)
        .value((d) => d.value ?? 0)
        .sort(null),
    [minPercentage]
  );

  const pieArcDatums = useMemo(() => pieGenerator(data), [pieGenerator, data]);

  const innerRadius = radius - strokeWidth;

  const outerRadius = radius;

  const createArc = useMemo(
    () =>
      arc<unknown>()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius)
        .cornerRadius(16)
        .padAngle(0.045),
    [innerRadius, outerRadius]
  );

  const localRadius = useMemo(
    () => d3local<{ innerRadius: number; outerRadius: number }>(),
    []
  );

  const localFilter = useMemo(() => d3local<string>(), []);

  useEffect(() => {
    const svg = select(svgRef.current);

    const g = svg
      .append('g')
      .attr('transform', `translate(${chartSize / 2}, ${chartSize / 2})`);

    g.selectAll('path')
      .data(pieArcDatums)
      .enter()
      .append('path')
      .attr('d', function handler(d) {
        if (!matchedSegmentByLabel || matchedSegmentByLabel?.[d.data.name]) {
          localRadius.set(this, { innerRadius, outerRadius });
          return createArc.innerRadius(innerRadius).outerRadius(outerRadius)(d);
        }
        localRadius.set(this, {
          innerRadius: innerRadius + strokeSizeDiff,
          outerRadius: outerRadius - strokeSizeDiff,
        });
        return createArc
          .innerRadius(innerRadius + strokeSizeDiff)
          .outerRadius(outerRadius - strokeSizeDiff)(d);
      })
      .attr('filter', function handler(d) {
        if (matchedSegmentByLabel?.[d.data.name]) {
          localFilter.set(this, theme.__hd__.chart.shadows.pie.slice);
          return theme.__hd__.chart.shadows.pie.slice;
        }
        localFilter.set(this, 'none');
        return 'none';
      })
      .attr('fill', (d) => colorScale(d.data.name))
      .attr('data-test-id', (d) =>
        dataTestId ? `${dataTestId}-slice-${d.data.name}` : null
      )
      .style('cursor', onClick ? 'pointer' : 'unset');

    const tooltip = select(tooltipRef.current)
      .style('position', 'fixed')
      .style('display', 'none')
      .style('opacity', '0%');
    // add mouseover, mousemove, and mouseout events to the paths
    svg
      .selectAll('path')
      .on('mouseover', function handler(...args) {
        const e = args[0];
        const selected = args[1] as PieArcDatum<InternalChartData>;
        itemConfig?.onMouseOver?.(e, selected.data.originalData);

        select(this)
          .raise()
          .transition('size')
          .attr('d', (d) => {
            return createArc.innerRadius(innerRadius).outerRadius(outerRadius)(
              d
            );
          });

        select(this)
          .raise()
          .attr('filter', theme.__hd__.chart.shadows.pie.slice);

        g.selectAll('path')
          .filter((d) => {
            return d !== selected;
          })
          .transition('arc')
          .attr('filter', 'none')
          .attr('d', (d) => {
            return createArc
              .innerRadius(innerRadius + strokeSizeDiff)
              .outerRadius(outerRadius - strokeSizeDiff)(d);
          });
        const { clientX, clientY } = args[0];
        tooltip
          .style('left', `${clientX}px`)
          .style(
            'top',
            `${clientY - theme.__hd__.chart.spaces.pie.tooltipTopPosition}px`
          );
        tooltip.transition().style('display', 'block').style('opacity', '100%');

        setCurrentIndex(selected.index);
      })
      .on('mousemove', (event) => {
        const { clientX, clientY } = event;
        tooltip
          .style('left', `${clientX}px`) // position the tooltip to the right of the mouse pointer
          .style(
            'top',
            `${clientY - theme.__hd__.chart.spaces.pie.tooltipTopPosition}px`
          ); // position the tooltip below the mouse pointer
      })
      .on('mouseout', function handler(...args) {
        const e = args[0];
        const selected = args[1] as PieArcDatum<InternalChartData>;
        itemConfig?.onMouseOut?.(e, selected.data.originalData);
        const originalFilter = localFilter.get(this as Element) || 'none';
        select(this).attr('filter', originalFilter);
        tooltip.transition().style('display', 'none').style('opacity', '0%');

        g.selectAll('path')
          .transition('arc')
          .attr('d', function _handler(d) {
            const originalRadius = localRadius.get(this as Element) || {
              innerRadius,
              outerRadius,
            };
            return createArc
              .innerRadius(originalRadius.innerRadius)
              .outerRadius(originalRadius.outerRadius)(d);
          })
          .attr('filter', function __handler() {
            return localFilter.get(this as Element) || 'none';
          });

        setCurrentIndex(undefined);
      })
      .on('click', function handler(e: PointerEvent, selected: unknown) {
        const {
          data: { name },
        } = selected as PieArcDatum<InternalChartData>;
        const series = originalData.find((item) => item.label === name);
        // Return original series data for reference equality
        if (series) onClick?.(e, series);
      });
    return () => {
      svg.selectAll('*').remove();
    };
  }, [
    colors,
    data,
    diametter,
    radius,
    strokeWidth,
    hoverStrokeWidth,
    theme,
    total,
    sliceGap,
    dataTestId,
    strokeSizeDiff,
    colorScale,
    createArc,
    innerRadius,
    outerRadius,
    pieArcDatums,
    onClick,
    originalData,
    matchedSegmentByLabel,
    localRadius,
    localFilter,
    itemConfig,
    chartSize,
  ]);

  const selected = data[currentIndex ?? -1];

  const percentage = (100 * (selected?.value ?? 0)) / total;

  const renderValue = () =>
    !!percentage && !!selected?.value ? (
      <Box
        sx={{
          flexDirection: 'column',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        <Box tagName="span" sx={{ display: 'flex', alignItems: 'flex-end' }}>
          <Typography.Title level={getTitleLevel(size)}>
            {percentage.toFixed(0)}
          </Typography.Title>
          <Typography.Text fontWeight="light">%</Typography.Text>
        </Box>
        {!!selected?.value && size !== 'small' && (
          <Typography.Text fontWeight="light" fontSize={14}>
            {totalFormatter(total)} {totalText}
          </Typography.Text>
        )}
      </Box>
    ) : null;

  const renderTotal = () => {
    return (
      <Box
        sx={{
          flexDirection: 'column',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        <Typography.Title level={getTitleLevel(size)}>
          {totalFormatter(total)}
        </Typography.Title>
        {size !== 'small' && (
          <Typography.Text fontWeight="light">{totalText}</Typography.Text>
        )}
      </Box>
    );
  };

  const renderIcon = () =>
    selected?.icon ? (
      <StyledIconContainer>
        <Icon icon={selected?.icon} intent="primary" />
      </StyledIconContainer>
    ) : null;

  const labels = useMemo(
    () => originalData.map((item) => item.label),
    [originalData]
  );

  const prevLabels = usePrevious(labels);

  const labelsDiff = useMemo(
    () => difference(labels, prevLabels || []),
    [labels, prevLabels]
  );

  useEffect(() => {
    setInternalSelectedLegends((prev) => {
      return Array.from(new Set([...prev, ...labelsDiff]));
    });
  }, [labelsDiff]);

  const renderLegend = () => {
    if (typeof legendConfig !== 'undefined') {
      if (legendConfig?.selectable) {
        return (
          <LegendCheckboxGroup
            data={originalData}
            getDisplayText={(item) => item.label}
            getValue={(item) => item.label}
            getColor={(item) => colorScale(item.label)}
            value={selectedLegends}
            onChange={setInternalSelectedLegends}
            sx={{ mt: title ? 0 : size }}
            data-test-id={
              dataTestId ? `${dataTestId}-checkbox-legend` : undefined
            }
            {...legendConfig}
          />
        );
      }
      return (
        <LegendGroup
          data={originalData}
          getDisplayText={(item) => item.label}
          getColor={(item) => colorScale(item.label)}
          sx={{ mt: title ? 0 : size }}
          data-test-id={dataTestId ? `${dataTestId}-legend` : undefined}
          {...legendConfig}
        />
      );
    }
    return null;
  };

  const renderInnerContent = () => {
    if (centralContentRenderer) {
      return centralContentRenderer();
    }
    if (!selected) {
      if (alwaysShowTotal) return renderTotal();
    }
    if (selected?.icon) return renderIcon();
    return renderValue();
  };

  return (
    <StyledChartContainer
      id={id}
      className={className}
      data-test-id={dataTestId}
      style={{ ...style, ...useCss(sx) }}
    >
      <StyledPieChartContainer themeSize={size}>
        <StyledTooltip ref={tooltipRef} variant="light">
          <Box
            sx={{
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
            }}
          >
            <StyledLegendDot themeColor={colorScale(selected?.name)} />
            <Typography.Text
              fontSize={12}
              fontWeight="light"
              intent="subdued"
              sx={{ marginLeft: 'xsmall' }}
            >
              {selected?.name}
            </Typography.Text>
            <Typography.Text
              fontSize={12}
              fontWeight="light"
              tagName="span"
              sx={{ marginLeft: 'xsmall' }}
            >
              {selected?.value}
            </Typography.Text>
            <Typography.Text
              fontSize={12}
              fontWeight="light"
              tagName="span"
              sx={{ marginLeft: 'xsmall' }}
            >
              ({percentage?.toFixed(0)}%)
            </Typography.Text>
          </Box>
        </StyledTooltip>
        <svg ref={svgRef} width={chartSize} height={chartSize} />

        <StyledInnerContentContainer
          data-test-id={dataTestId ? `${dataTestId}-inner-content` : undefined}
        >
          {renderInnerContent()}
        </StyledInnerContentContainer>
      </StyledPieChartContainer>
      {title && (
        <StyledTitleContainer>
          <StyledChartTitle
            fontSize={12}
            fontWeight="semi-bold"
            data-test-id={dataTestId ? `${dataTestId}-title` : undefined}
          >
            {title}
          </StyledChartTitle>
        </StyledTitleContainer>
      )}
      {renderLegend()}
    </StyledChartContainer>
  );
};

export default PieChart;
