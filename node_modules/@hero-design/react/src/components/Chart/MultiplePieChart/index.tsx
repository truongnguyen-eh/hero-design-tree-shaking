import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import { DefaultTheme, useTheme } from 'styled-components';
import { PieArcDatum, arc, pie, select, local as d3local } from 'd3';
import { CommonProps } from '../../common';
import {
  StyledChartContainer,
  StyledMultiplePieChartContainer,
} from './StyledMultiplePieChart';
import { useCss } from '../../../utils/hooks';
import Box from '../../Box';
import Typography from '../../Typography';
import { StyledLegendDot } from '../Legend/StyledLegend';
import {
  StyledChartSubTitle,
  StyledChartTitle,
  StyledTitleContainer,
  StyledTooltip,
} from '../StyledChart';
import { LegendConfig, MatchedSegment, Series, StyleConfig } from '../type';
import LegendCheckboxGroup from '../Legend/LegendCheckboxGroup';
import LegendGroup from '../Legend/LegendGroup';
import { difference, filterElementHasNoColor, usePrevious } from '../utils';
import { useColorScale } from '../common/colorScale';

type Slice = {
  value: number;
  label: string;
  labelIndex: number;
  index: number;
  pieLabel: string;
};

export interface MultiplePieChartProps extends CommonProps {
  /**
   * Data to be displayed in pie chart.
   */
  data: Array<Series<Array<number | undefined>>>;
  /**
   * Data configuration for each Pie.
   */
  labels: Array<string>;
  /**
   * Title of chart.
   */
  title?: string;
  /**
   * Legend configuration.
   */
  legendConfig?: LegendConfig;
  /**
   * onClick handler.
   */
  onClick?: (e: PointerEvent, value: Slice) => void;
  /**
   * Matched pattern to highlight the bars.
   */
  highlightedItems?: MatchedSegment;
  /**
   * * styleConfig use to custom the style of the chart.
   * * styleConfig must be an object:
   *    * color?: use to custom the legend colors.
   */
  styleConfig?: StyleConfig;
}

const getDiametterFromSize = (size: 'large', theme: DefaultTheme) => {
  return theme.__hd__.chart.sizes.multiplePie[size];
};

const getStrokeWidth = (size: 'large', theme: DefaultTheme) => {
  return theme.__hd__.chart.sizes.multiplePie.stokes[size];
};

const getRestHoverStrokeWidth = (size: 'large', theme: DefaultTheme) => {
  return theme.__hd__.chart.sizes.multiplePie.restHoverStrokes[size];
};

// Maximum number of pie
const MAX_ARC = 4;

const ANGLE_PADDING = Math.PI / 12;

const MultiplePieChart = (props: MultiplePieChartProps) => {
  const {
    data,
    sx = {},
    style,
    'data-test-id': dataTestId,
    className,
    legendConfig,
    title,
    id,
    labels: originalLabels,
    onClick,
    highlightedItems,
    styleConfig,
  } = props;
  const [currentSlice, setCurrentSlice] = useState<Slice | undefined>(
    undefined
  );
  const size = 'large';
  const theme = useTheme();
  const diametter = getDiametterFromSize(size, theme);
  const radius = diametter / 2;
  const strokeWidth = getStrokeWidth(size, theme);
  const restHoverStrokeWidth = getRestHoverStrokeWidth(size, theme);
  const strokeSizeDiff = (strokeWidth - restHoverStrokeWidth) / 2;
  const { strokeGap } = theme.__hd__.chart.spaces.multiplePie;

  const matchedSegmentByLabel = useMemo(() => {
    return highlightedItems?.reduce(
      (acc: { [key: string]: { [key: string]: boolean } }, item) => {
        acc[item.label] = acc[item.label] || {};
        acc[item.label][item.legend] = true;
        return acc;
      },
      {}
    );
  }, [highlightedItems]);

  const [internalSelectedLegends, setInternalSelectedLegends] = useState<
    string[]
  >([]);

  const selectedLegends = useMemo(
    () =>
      legendConfig?.selectable
        ? legendConfig?.value || internalSelectedLegends
        : internalSelectedLegends,
    [internalSelectedLegends, legendConfig]
  );

  const selectedLegendByName = useMemo(
    () =>
      selectedLegends.reduce((acc: { [key: string]: boolean }, legend) => {
        acc[legend] = true;
        return acc;
      }, {}),
    [selectedLegends]
  );

  const labels = useMemo(
    () =>
      data
        ?.map(({ label }, labelIndex) => ({ label, labelIndex }))
        ?.filter(({ label }) => selectedLegendByName?.[label]),
    [data, selectedLegendByName]
  );

  const tooltipRef = useRef(null);
  const svgRef = useRef(null);

  const pieLabels = useMemo(
    () => originalLabels?.slice(0, MAX_ARC),
    [originalLabels]
  );

  const calcInnerRadius = useCallback(
    (index: number) => radius - strokeWidth - index * (strokeWidth + strokeGap),
    [radius, strokeGap, strokeWidth]
  );

  const calcOuterRadius = useCallback(
    (index: number) => radius - index * (strokeWidth + strokeGap),
    [radius, strokeGap, strokeWidth]
  );

  const arcs = useMemo(
    () =>
      pieLabels?.map((_, index) =>
        arc<unknown>()
          .innerRadius(calcInnerRadius(index))
          .outerRadius(calcOuterRadius(index))
          .cornerRadius(16)
          .padAngle(0.045)
      ),
    [calcInnerRadius, calcOuterRadius, pieLabels]
  );

  const pieGenerators = useMemo(
    () =>
      pieLabels?.map((_, index) => {
        const series = data?.map((item) => item?.data?.[index]);
        const filteredSeries = series?.filter(
          (value): value is number => value !== undefined
        );
        const minValue = Math.min(...filteredSeries);
        const total = filteredSeries.reduce((acc, value) => acc + value, 0);
        const minPercentage = (minValue / total) * 100;

        return pie<Slice>()
          .startAngle(0)
          .padAngle(minPercentage < 5 ? ANGLE_PADDING : 0)
          .sort(null);
      }),
    [data, pieLabels]
  );

  const customColors = useMemo(
    () =>
      styleConfig?.series !== undefined
        ? filterElementHasNoColor(styleConfig.series)
        : undefined,
    [styleConfig?.series]
  );

  const legends = useMemo(() => data.map((item) => item.label), [data]);

  const colorScale = useColorScale(legends, customColors);

  const localRadius = useMemo(
    () => d3local<{ innerRadius: number; outerRadius: number }>(),
    []
  );

  const localFilter = useMemo(() => d3local<string>(), []);

  useEffect(() => {
    const svg = select(svgRef.current);
    const tooltip = select(tooltipRef.current)
      .style('position', 'fixed')
      .style('display', 'none')
      .style('opacity', '0%');
    arcs.forEach((createArc, index) => {
      const g = svg
        .append('g')
        .attr('transform', `translate(${radius}, ${radius})`);
      const pieGenerator = pieGenerators[index];
      const pieArcDatums = pieGenerator.value((p) => p.value)(
        labels.map(({ label, labelIndex }) => {
          return {
            value: data?.[labelIndex]?.data?.[index] ?? 0,
            label,
            index,
            labelIndex,
            pieLabel: pieLabels?.[index],
          };
        })
      );
      g.selectAll('path')
        .data(pieArcDatums)
        .enter()
        .append('path')
        .attr('d', function handler(d) {
          const innerRadius = calcInnerRadius(d.data.index);
          const outerRadius = calcOuterRadius(d.data.index);
          if (
            !matchedSegmentByLabel ||
            matchedSegmentByLabel?.[d.data.pieLabel]?.[d.data.label]
          ) {
            localRadius.set(this, { innerRadius, outerRadius });
            return createArc.innerRadius(innerRadius).outerRadius(outerRadius)(
              d
            );
          }
          localRadius.set(this, {
            innerRadius: innerRadius + strokeSizeDiff,
            outerRadius: outerRadius - strokeSizeDiff,
          });
          return createArc
            .innerRadius(innerRadius + strokeSizeDiff)
            .outerRadius(outerRadius - strokeSizeDiff)(d);
        })
        .attr('filter', function handler(d) {
          if (matchedSegmentByLabel?.[d.data.pieLabel]?.[d.data.label]) {
            localFilter.set(this, theme.__hd__.chart.shadows.pie.slice);
            return theme.__hd__.chart.shadows.pie.slice;
          }
          localFilter.set(this, 'none');
          return 'none';
        })
        .attr('fill', (d) => colorScale(d.data.label))
        .attr('data-test-id', (d) =>
          dataTestId
            ? `${dataTestId}-arc-${String(d.data.pieLabel)}-slice-${String(
                d.data.label
              )}`
            : null
        )
        .style('cursor', onClick ? 'pointer' : 'unset');

      g.selectAll('path')
        .on('mouseover', function handler(...args) {
          const selected = args[1] as PieArcDatum<Slice>;

          select(this)
            .raise()
            .transition()
            .attr('d', (d) => {
              const i = (d as PieArcDatum<Slice>).data.index;
              return arcs[i]
                .innerRadius(calcInnerRadius(i))
                .outerRadius(calcOuterRadius(i))(d);
            });

          select(this)
            .raise()
            .transition('shadow')
            .attr('filter', theme.__hd__.chart.shadows.multiplePie.slice);
          svg
            .selectAll('path')
            .filter((d) => {
              return d !== selected;
            })
            .transition('arc')
            .attr('d', (d) => {
              const { index: i } = (d as { data: { index: number } }).data;
              const newArc = arcs[i];
              return newArc
                .innerRadius(calcInnerRadius(i) + strokeSizeDiff)
                .outerRadius(calcOuterRadius(i) - strokeSizeDiff)(d);
            });

          // show the tooltip when the mouse enters a slice
          tooltip
            .transition()
            .duration(200)
            .style('display', 'block')
            .style('opacity', '100%');
          setCurrentSlice(selected.data);
        })
        .on('mousemove', (event) => {
          tooltip
            .style('left', `${event.clientX}px`) // position the tooltip to the right of the mouse pointer
            .style('top', `${event.clientY - 12}px`); // position the tooltip below the mouse pointer
        })
        .on('mouseout', function handler() {
          const originalFilter = localFilter.get(this as Element) || 'none';
          select(this).transition('shadow').attr('filter', originalFilter);
          svg
            .selectAll('path')
            .transition('arc')
            .attr('d', function _handler(d) {
              const { index: i } = (d as { data: Slice }).data;
              const originalRadius = localRadius.get(this as Element);
              const newArc = arcs[i];
              return newArc
                .innerRadius(originalRadius?.innerRadius || calcInnerRadius(i))
                .outerRadius(originalRadius?.outerRadius || calcOuterRadius(i))(
                d
              );
            });

          tooltip.style('opacity', '0%').style('display', 'none');
          setCurrentSlice(undefined);
        })
        .on('click', function handler(e: PointerEvent, selected: unknown) {
          onClick?.(e, (selected as PieArcDatum<Slice>).data);
        });
    });
    return () => {
      svg.selectAll('*').remove();
    };
  }, [
    arcs,
    radius,
    data,
    theme.__hd__.chart.colors.pie.background,
    theme,
    labels,
    pieGenerators,
    strokeGap,
    strokeWidth,
    calcInnerRadius,
    calcOuterRadius,
    strokeSizeDiff,
    dataTestId,
    colorScale,
    onClick,
    matchedSegmentByLabel,
    localRadius,
    localFilter,
    pieLabels,
  ]);

  const total = useMemo(() => {
    if (currentSlice === undefined) return 0;
    return (
      data?.reduce((acc, series) => {
        return acc + (series?.data?.[currentSlice.index] ?? 0);
      }, 0) ?? 0
    );
  }, [currentSlice, data]);

  const selectedValue =
    data?.[currentSlice?.labelIndex ?? -1]?.data?.[currentSlice?.index ?? -1];

  const selectedLabel = currentSlice?.label;

  const selectedPieLabel = pieLabels?.[currentSlice?.index ?? -1];

  const percentage = useMemo(() => {
    if (currentSlice === undefined) return 0;
    return (100 * (selectedValue ?? 0)) / total;
  }, [currentSlice, selectedValue, total]);

  const prevLegends = usePrevious(legends);

  const labelsDiff = useMemo(
    () => difference(legends, prevLegends || []),
    [legends, prevLegends]
  );

  useEffect(() => {
    setInternalSelectedLegends((prev) => {
      return Array.from(new Set([...prev, ...labelsDiff]));
    });
  }, [labelsDiff]);

  const renderLegend = () => {
    if (typeof legendConfig !== 'undefined') {
      if (legendConfig?.selectable) {
        return (
          <LegendCheckboxGroup
            data={legends}
            getDisplayText={(item) => item}
            getValue={(item) => item}
            getColor={(item) => colorScale(item)}
            value={selectedLegends}
            onChange={setInternalSelectedLegends}
            sx={{ mt: title ? 0 : size }}
            data-test-id={
              dataTestId ? `${dataTestId}-checkbox-legend` : undefined
            }
            {...legendConfig}
          />
        );
      }
      return (
        <LegendGroup
          data={legends}
          getDisplayText={(item) => item}
          getColor={(item) => colorScale(item)}
          sx={{ mt: title ? 0 : size }}
          data-test-id={dataTestId ? `${dataTestId}-legend` : undefined}
          {...legendConfig}
        />
      );
    }
    return null;
  };

  return (
    <StyledChartContainer
      id={id}
      className={className}
      data-test-id={dataTestId}
      style={{ ...style, ...useCss(sx) }}
    >
      <StyledMultiplePieChartContainer themeSize={size}>
        <StyledTooltip
          style={{ display: !selectedLabel ? 'none' : undefined }}
          ref={tooltipRef}
          variant="light"
        >
          <Box
            sx={{
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
            }}
          >
            <StyledLegendDot themeColor={colorScale(selectedLabel || '')} />
            <Typography.Text
              fontSize={12}
              fontWeight="light"
              intent="subdued"
              sx={{ marginLeft: 'xsmall' }}
            >
              {selectedPieLabel} | {selectedLabel}
            </Typography.Text>
            <Typography.Text
              fontSize={12}
              fontWeight="light"
              tagName="span"
              sx={{ marginLeft: 'xsmall' }}
            >
              {selectedValue}
            </Typography.Text>
            <Typography.Text
              fontSize={12}
              fontWeight="light"
              tagName="span"
              sx={{ marginLeft: 'xsmall' }}
            >
              ({percentage?.toFixed(0)}%)
            </Typography.Text>
          </Box>
        </StyledTooltip>
        <svg
          ref={svgRef}
          width={diametter}
          height={diametter}
          overflow="visible"
        />
      </StyledMultiplePieChartContainer>
      {title && (
        <StyledTitleContainer>
          <StyledChartTitle
            fontSize={12}
            fontWeight="semi-bold"
            data-test-id={dataTestId ? `${dataTestId}-title` : undefined}
          >
            {title}
          </StyledChartTitle>
          {pieLabels?.length > 1 && (
            <StyledChartSubTitle fontSize={10} fontWeight="semi-bold">
              Out to in: {pieLabels?.join(', ')}
            </StyledChartSubTitle>
          )}
        </StyledTitleContainer>
      )}
      {renderLegend()}
    </StyledChartContainer>
  );
};

export default MultiplePieChart;
