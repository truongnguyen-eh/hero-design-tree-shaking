import React, { useCallback, useMemo, useState } from 'react';
import * as d3 from 'd3';
import { useTheme } from 'styled-components';
import Rect from './Rect';
import { BarConfig, MatchedSegment, Series, YAxisConfig } from '../../type';
import { CommonProps } from '../../../common';
import { DataValue } from '../../LineChart/types';
import TotalBadge from './TotalBadge';
import useSeries from '../../common/useSeries';

type BarData = {
  legend: string;
  value: number;
  color: string;
  label: string;
  percent: number;
  yAxisLabel: string;
};

interface BarAreaProps extends CommonProps {
  width: number;
  height: number;
  maxValue: number;
  minValue: number;
  yAxisConfig?: Omit<YAxisConfig, 'maxValue'>;
  highlightedItems?: MatchedSegment;
  barConfig?: BarConfig<DataValue>;
  onMouseOver: (e: PointerEvent, barData: BarData) => void;
  onMouseOut: (e: PointerEvent) => void;
  onMouseMove: (e: PointerEvent) => void;
  selectedLegends: string[];
  data: Array<Series<Array<DataValue>> & { color: string }>;
  barSize?: BarConfig<DataValue>['size'];
}

const MIN_DISPLAY_PERCENTAGE = 2 / 100;

const BarArea = ({
  yAxisConfig,
  height,
  width,
  maxValue,
  minValue,
  'data-test-id': dataTestId,
  highlightedItems,
  barConfig,
  onMouseOver,
  selectedLegends,
  data,
  onMouseOut,
  onMouseMove,
  barSize = 'large',
}: BarAreaProps) => {
  const theme = useTheme();

  const {
    __hd__: { barChart: barChartTheme },
  } = theme;

  const { barMarginLeft, barMarginTop } = barChartTheme.space;

  const labels = useMemo(
    () => yAxisConfig?.labels || [],
    [yAxisConfig?.labels]
  );

  const [activeBar, setActiveBar] = useState<BarData | undefined>(undefined);

  const series = useSeries({
    legends: selectedLegends,
    maxValue,
    minDisplayPercentage: MIN_DISPLAY_PERCENTAGE,
    data,
    labels,
  });

  const yScale = useMemo(() => {
    return d3
      .scaleBand<string>()
      .domain(labels as Iterable<string>)
      .range([0, height]);
  }, [labels, height]);

  const xScale = useMemo(() => {
    return d3.scaleLinear().domain([minValue, maxValue]).range([0, width]);
  }, [minValue, maxValue, width]);

  const matchedHighlightedItems = useCallback(
    ({ legend, label }: { legend?: string; label?: string }) => {
      if (typeof highlightedItems === 'undefined') return undefined;
      const isMatchedSegmentNotEmpty = highlightedItems.length > 0;
      if (isMatchedSegmentNotEmpty) {
        return (
          highlightedItems &&
          highlightedItems.filter(
            (item) => item.label === label && item.legend === legend
          ).length > 0
        );
      }
      return false;
    },
    [highlightedItems]
  );

  const handleOnMouseOver = useCallback(
    (e, barData: BarData) => {
      const { color, legend, value, label, percent, yAxisLabel } = barData;
      onMouseOver(e, {
        legend,
        value,
        color,
        label,
        percent,
        yAxisLabel,
      });

      setActiveBar(barData);
    },
    [onMouseOver]
  );

  const handleOnMouseOut = useCallback(
    (e) => {
      onMouseOut(e);
      setActiveBar(undefined);
    },
    [onMouseOut]
  );

  const handleOnMouseMove = useCallback(
    (e) => {
      onMouseMove(e);
    },
    [onMouseMove]
  );

  const handleOnClicked = useCallback(
    (e, barData: BarData & { label?: string }) => {
      const { legend, label, value } = barData;
      barConfig?.onClick?.(e, {
        legend,
        label,
        data: value,
      });
    },
    [barConfig]
  );

  return (
    <g>
      {series.map((subgroup) => {
        return (
          <g
            key={subgroup.key}
            transform={`translate(0, ${Math.floor(
              yScale.bandwidth() / 2 - barMarginLeft
            )})`}
          >
            {subgroup.map((group) => {
              const prevBarValue = group[0];
              const currentValue = group[1];

              if (Number.isNaN(prevBarValue) || Number.isNaN(currentValue)) {
                return null;
              }

              const legend = subgroup.key;

              const { color } = data.filter((d) => d.label === legend)[0];

              const rectValue = Number(group.data.data[subgroup.key]);
              const { label } = group.data;

              const isActive =
                typeof activeBar !== 'undefined'
                  ? activeBar?.legend === legend &&
                    activeBar.value === rectValue &&
                    activeBar.color === color &&
                    activeBar.label === label
                  : undefined;

              const rectX = Math.round(xScale(group[0]));
              const rectY = Math.round(yScale(group.data.label) ?? 0);

              const isLastBar =
                subgroup.key === selectedLegends[selectedLegends.length - 1];
              const barWidth =
                xScale(group[1]) -
                xScale(group[0]) -
                (isLastBar ? 0 : barMarginLeft);

              const isLastLegend =
                subgroup.key === selectedLegends[selectedLegends.length - 1];

              const total = Object.entries(group.data)
                .filter(([key]) => selectedLegends.includes(key))
                .reduce((acc, [_key, value]) => {
                  return Number(acc) + Number(value);
                }, 0);
              const percent = Math.round((rectValue / total) * 100);
              return (
                <>
                  <Rect
                    isHovered={isActive}
                    key={label + legend}
                    onMouseOver={(e) => {
                      handleOnMouseOver(e, {
                        legend: subgroup.key,
                        value: rectValue,
                        color,
                        label,
                        percent,
                        yAxisLabel: label,
                      });
                    }}
                    onMouseOut={handleOnMouseOut}
                    onMouseMove={handleOnMouseMove}
                    onClick={(e) => {
                      if (typeof rectValue !== 'number') return;
                      handleOnClicked(e, {
                        legend: subgroup.key,
                        value: rectValue,
                        color,
                        label,
                        percent,
                        yAxisLabel: label,
                      });
                    }}
                    isHighlighted={matchedHighlightedItems({
                      legend,
                      label,
                    })}
                    data-test-id={
                      dataTestId &&
                      `${dataTestId}-${label}-${legend}-${currentValue}`
                    }
                    color={color}
                    width={Math.round(barWidth)}
                    x={rectX}
                    y={rectY}
                    size={barSize}
                  />
                  {barConfig?.showTotal && isLastLegend && (
                    <TotalBadge
                      total={total}
                      totalFormatter={barConfig.totalFormatter}
                      x={rectX + barWidth + barMarginLeft}
                      y={(rectY || 0) - barMarginTop}
                      data-test-id={
                        dataTestId ? `${dataTestId}-total-badge` : undefined
                      }
                    />
                  )}
                </>
              );
            })}
          </g>
        );
      })}
    </g>
  );
};

export default BarArea;
