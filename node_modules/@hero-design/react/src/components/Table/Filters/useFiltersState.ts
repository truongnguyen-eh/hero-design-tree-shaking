import { useCallback, useEffect, useState } from 'react';
import type { FilterValues } from './types';

export type CacheProvider<T> = {
  load: () => Promise<T | null>;
  save: (value: T) => Promise<void>;
};

const saveValueToLS = <T>(key: string, value: T) => {
  return Promise.resolve(localStorage.setItem(key, JSON.stringify(value)));
};

const getValueFromLS = <T>(key: string) => {
  const str = localStorage.getItem(key);

  return Promise.resolve(str === null ? null : (JSON.parse(str) as T));
};

export const getLSCacheProvider = <T>(cacheKey: string): CacheProvider<T> => {
  return {
    save: (value) => saveValueToLS(cacheKey, value),
    load: () => getValueFromLS(cacheKey),
  };
};

type UseFiltersStateInput<T extends FilterValues> = {
  cacheOnChange?: boolean;
  cacheProvider?: CacheProvider<T>;
  initialValues: T;
};

type UseFiltersStateOutput<T extends FilterValues> = {
  cacheValues: () => void;
  filterValues: T;
  loadingCache: boolean;
  resetCache: () => void;
  resetFilters: () => void;
  setFilterValues: (newFilterValues: T) => void;
};

const useFiltersState = <T extends FilterValues>({
  initialValues,
  cacheProvider,
  cacheOnChange = false,
}: UseFiltersStateInput<T>): UseFiltersStateOutput<T> => {
  const [filterValues, setFilterValues] = useState<T>(initialValues);
  const [loadingCache, setCacheLoading] = useState(cacheProvider !== undefined);

  useEffect(() => {
    if (cacheProvider === undefined) return;

    cacheProvider.load().then((cacheValue) => {
      setCacheLoading(false);
      if (cacheValue !== null) setFilterValues(cacheValue);
    });
  }, [cacheProvider]);

  const persistentSetValues = useCallback(
    (values: T) => {
      setFilterValues(values);
      cacheProvider?.save(values);
    },
    [cacheProvider]
  );

  const exposedSetValues = cacheOnChange
    ? persistentSetValues
    : setFilterValues;

  const cacheValues = useCallback(() => {
    cacheProvider?.save(filterValues);
  }, [cacheProvider, filterValues]);

  const resetCache = useCallback(
    () => cacheProvider?.save(initialValues),
    [cacheProvider, initialValues]
  );

  const resetFilters = useCallback(
    () => exposedSetValues(initialValues),
    [initialValues, exposedSetValues]
  );

  return {
    filterValues,
    setFilterValues: exposedSetValues,
    loadingCache,
    cacheValues,
    resetCache,
    resetFilters,
  };
};

export default useFiltersState;
