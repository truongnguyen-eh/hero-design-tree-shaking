import React, { useMemo, useState } from 'react';
import {
  useTable,
  useSortBy,
  useRowSelect,
  useFilters,
  useExpanded,
  HeaderProps,
} from 'react-table';
import type { ReactElement, ReactNode } from 'react';
import type {
  Column as RTColumn,
  Row,
  Filters,
  IdType,
  SortingRule,
  Hooks,
  HeaderGroup,
  UseSortByOptions,
  CellProps,
  Cell,
  FilterValue,
  UseSortByColumnOptions,
} from 'react-table';
import { useCss, useDeprecation, useResizeObserver } from '../../utils/hooks';

import StyledTable, {
  StyledTableWrapper,
  StyledTHead,
  StyledTBody,
  StyledTD,
  StyledPaginationWrapper,
  StyledItemsPerPageSelect,
  StyledEmptyTableContent,
} from './StyledTable';
import TableTH from './TableTH';

import Spinner from '../Spinner';
import Pagination from '../Pagination';

import useRowExpansionUI from './useRowExpansionUI';

import { flatMap, fromUndefinedable, getOrElse, map } from '../../fp/Option';
import {
  always,
  equal,
  invokeWith,
  noop,
  pipe,
  isDefined,
} from '../../fp/function';
import { find, reject } from '../../fp/Array';
import useColumnLefts from './useColumnLefts';
import type { CommonProps } from '../common';
import Checkbox from '../Checkbox';

type ColumnProps = {
  align?: 'left' | 'right' | 'center';
};

type Column<T extends Record<string, unknown> = Record<string, unknown>> =
  RTColumn<T> & UseSortByOptions<T> & ColumnProps;

type BulkCheckProps = {
  checked: boolean | undefined;
  onChange: (() => void) | undefined;
  indeterminate: boolean | undefined;
  disabled: boolean | undefined;
};

type BulkCheckHeaderProps<D extends Record<string, unknown>> = {
  rows: Row<D>[];
} & BulkCheckProps;

type BulkCheckItemProps<D extends Record<string, unknown>> = {
  row: Row<D>;
} & BulkCheckProps;

type BulkCheckSettingsProps<D extends Record<string, unknown>> = {
  disableCheckRule?: (row: Row<D>) => boolean;
  bulkHeaderRenderer?: (
    bulkCheckHeader: BulkCheckHeaderProps<D>
  ) => React.ReactElement;
  bulkItemRerender?: (
    bulkCheckItem: BulkCheckItemProps<D>
  ) => React.ReactElement;
};

export type {
  Column,
  IdType,
  Row,
  Filters,
  SortingRule,
  BulkCheckProps,
  BulkCheckHeaderProps,
  BulkCheckItemProps,
  BulkCheckSettingsProps,
  CellProps,
  UseSortByOptions,
  Cell,
  FilterValue,
  UseSortByColumnOptions,
};

export interface TableProps<D extends Record<string, unknown>>
  extends CommonProps {
  /**
   * Array of table columns. Some notes when you provide this prop:
   * * Must be memoized.
   * * Column must be an object of:
   *     * Cell?: a React component to render the cell at column. Checkout this example https://design.employmenthero.com/web/Components/Table/#cell-customisation for further information.
   *     * Filter?: @deprecated - a React component to render the column filter.
   *     * Header?: a string or React component to render the column header.
   *     * accessor?: a string as the path of the data element's property.
   *     * align?: one of 'left' | 'right' to handle the text alignment.
   *     * disableSortBy?: a boolean to enable/disable column sorting (default is false)
   *     * displayAtBreakpoint?: one of 'sm' | 'md' | 'lg' | 'xl' to handle the column rendering depending on media query breakpoints.
   *     * width?: a string to specify an explicit width of the column.
   */
  columns: Column<D>[];
  /**
   * Array of D (D is the generic type of data element you pass in).
   */
  data: D[];
  /**
   * Controlled expanded rows state, expandedRows is an object of:
   * - key: row index.
   * - value: boolean. True means the row at index is expanded.
   */
  expandedRows?: Record<IdType<D>, boolean>;
  /**
   * Whether the table has expanded rows. When expansion is available, its data shape must be an object of:
   * - expandedRowRenderer: a render function '(rowData: D) => ReactElement' to render the expanded row.
   * - rowExpandable: a predicate function '(rowData: D) => boolean' to decide a row is expandable or not.
   */
  expansion?: {
    expandedRowRenderer: (rowData: D) => ReactElement;
    rowExpandable: (rowData: D) => boolean;
  };
  /**
   * Controlled filters value, Filters is an array of:
   * - id: column id, this matches with accessor configuration.
   * - value: filter value
   */
  filters?: Filters<D>;
  /**
   * Whether the table's first column(s) sticks to the left when scroll horizontally on small screen size devices.
   */
  horizontallySticky?: boolean;
  /**
   * Controlled items per page, itemsPerPages is an object of:
   * - options: array of Select (https://design.employmenthero.com/web/Components/Select/#select-1) options.
   * - value: selected items per page value.
   */
  itemsPerPage?: {
    options: {
      text: string;
      value: string | number;
    }[];
    value?: string | number;
  };
  /**
   * Loading state of Table, which will render a spinner in the center of table.
   */
  loading?: boolean;
  /**
   * Content to render when there is no data in the table.
   */
  noData?: ReactNode;
  /**
   * Callback invoked when any row is expanded or collapsed. expandedRows is an object of:
   * - key: row index.
   * - value: boolean. True means the row at index is expanded.
   */
  onExpandedRowsChange?: (expandedRows: Record<IdType<D>, boolean>) => void;
  /**
   * Callback invoked when filters are changed. Filters is an array of:
   * - id: column id, this matches with accessor configuration.
   * - value: filter value
   */
  onFiltersChange?: (filters: Filters<D>) => void;
  /**
   * Callback invoked when items per page selection is changed.
   */
  onItemsPerPageChange?: (itemsPerPage: string | number) => void;
  /**
   * Callback invoked when a page in pagination is changed.
   */
  onPaginationChange?: (page: number) => void;
  /**
   * Callback invoked when any row is selected or deselected. selectedRows is an object of:
   * - key: row index.
   * - value: boolean. True means the row at index is selected.
   */
  onSelectedRowsChange?: (selectedRows: Record<IdType<D>, boolean>) => void;
  /**
   * Callback invoked when sorting is changed. sortBy is an array of:
   * - id: column id, this matches with accessor configuration.
   * - desc: boolean, true means sorting descendingly.
   */
  onSortByChange?: (sortBy: SortingRule<D>[]) => void;
  /**
   * Whether the table has pagination. When pagination is ON, its data shape must be an object of:
   * - current: a number which is 1-based indexing to indicate the current selected page.
   * - total: a number indicates the total of pages.
   */
  pagination?: {
    current: number;
    total: number;
  };
  /**
   * An object for rows configuration, it must be memoized.
   */
  rows?: {
    generateClassName?: (row: Row<D>) => string | undefined;
    /**
     * This function to help us detect unique rows and also how it constructs each row's underlying id property.
     */
    rowIdExtractor?: (row: D, index: number) => string;
  };
  /**
   * Whether the table is allowed using checkbox to select table rows.
   */
  selectable?: boolean;
  /**
   * Controlled selected rows state, selectedRows is an object of:
   * - key: key is the row id extracted from `rowIdExtractor`. Default value is row index.
   * - value: boolean. True means the row at index is selected.
   */
  selectedRows?: Record<IdType<D>, boolean>;
  /**
   * Controlled sortBy state, sortBy is an array of:
   * - id: column id, this matches with accessor configuration.
   * - desc: boolean, true means sorting descendingly.
   */
  sortBy?: SortingRule<D>[];
  /**
   * Enables sorting detection functionality, but does not automatically perform row sorting.
   * Turn this on if you wish to implement your own sorting outside of the table
   */
  manualSortBy?: boolean;
  /**
   * Whether the table's header sticks to the top.
   */
  sticky?: boolean;
  /**
   * The objects to custom the bulk check items, bulkCheckSettings is an object of:
   * - disableCheckRule: the function to help us set disabled for checkbox of specific row.
   * - bulkHeaderRenderer: the function to help us custom the select all checkbox.
   * - bulkItemRerender: the function to help us custom the item checkbox for each row.
   */
  bulkCheckSettings?: BulkCheckSettingsProps<D>;
}

export const hasFixedLayout = <D extends Record<string, unknown>>(
  columns: Column<D>[]
) => {
  const headerWithWidth = columns.find((header) =>
    Object.keys(header).includes('width')
  );

  return headerWithWidth !== undefined;
};

const SelectionCheckbox = (
  props: Omit<React.ComponentProps<typeof Checkbox>, 'value' | 'text'>
): ReactElement => (
  <Checkbox {...props} style={{ display: 'block' }} value="" text="" />
);

type TableActionType =
  | 'toggleRowSelected'
  | 'toggleAllRowsSelected'
  | 'toggleSortBy'
  | 'setFilter'
  | 'toggleRowExpanded';

function Table<D extends Record<string, unknown>>({
  columns,
  data,
  loading,
  sticky = false,
  horizontallySticky = false,
  selectable = false,
  selectedRows,
  onSelectedRowsChange,
  expansion,
  expandedRows,
  onExpandedRowsChange,
  pagination,
  rows: rowsConfig,
  onPaginationChange,
  itemsPerPage,
  onItemsPerPageChange,
  filters,
  onFiltersChange,
  sortBy,
  onSortByChange,
  manualSortBy,
  id,
  className,
  style,
  sx = {},
  'data-test-id': dataTestId,
  noData,
  bulkCheckSettings,
}: TableProps<D>): ReactElement {
  useDeprecation(
    'Filter property of a column is deprecated. It will be removed in the next major release of Hero-design!',
    columns.find((c) => c.Filter !== undefined) !== undefined
  );

  const { disableCheckRule, bulkHeaderRenderer, bulkItemRerender } =
    bulkCheckSettings || {};

  const useControlledState = React.useCallback(
    (state) => ({
      ...state,
      filters: pipe(
        fromUndefinedable(filters),
        getOrElse(() => state.filters)
      ),
      expanded: pipe(
        fromUndefinedable(expandedRows),
        getOrElse(() => state.expanded)
      ),
      sortBy: pipe(
        fromUndefinedable(sortBy),
        getOrElse(() => state.sortBy)
      ),
      selectedRowIds: pipe(
        fromUndefinedable(selectedRows),
        getOrElse(() => state.selectedRowIds)
      ),
    }),
    [filters, expandedRows, sortBy, selectedRows]
  );

  const RowSelectionHeader = React.useCallback(
    ({ rows }: HeaderProps<D>) => {
      const changeableRows = rows.filter((row) => {
        const isDisable = disableCheckRule ? disableCheckRule(row) : false;
        return !isDisable;
      });

      const allSelected = changeableRows.every((row) => row.isSelected);
      const allUnselected = changeableRows.every((row) => !row.isSelected);
      const disabled: boolean = changeableRows.length === 0;

      const selectionProps = {
        checked: allSelected,
        onChange: () =>
          changeableRows.forEach((row) => row.toggleRowSelected(!allSelected)),
        indeterminate: !allSelected && !allUnselected,
        disabled,
      };

      if (bulkHeaderRenderer) {
        return bulkHeaderRenderer({ ...selectionProps, rows });
      }

      return <SelectionCheckbox {...selectionProps} />;
    },
    [bulkHeaderRenderer, disableCheckRule]
  );

  const RowSelectionCell = React.useCallback(
    ({ row }: { row: Row<D> }) => {
      const disabled = disableCheckRule ? disableCheckRule(row) : false;
      const { onChange, checked, indeterminate } =
        row.getToggleRowSelectedProps();
      const selectionProps = {
        checked,
        onChange,
        indeterminate,
        disabled,
      };

      if (bulkItemRerender) {
        return bulkItemRerender({ ...selectionProps, row });
      }

      return <SelectionCheckbox {...selectionProps} />;
    },
    [bulkItemRerender, disableCheckRule]
  );

  const useRowSelectionUI = React.useCallback(
    (hooks: Hooks<D>) => {
      hooks.visibleColumns.push((cols) => [
        {
          id: 'selection',
          Header: RowSelectionHeader,
          Cell: RowSelectionCell,
        },
        ...cols,
      ]);
    },
    [RowSelectionCell, RowSelectionHeader]
  );

  const emptyHook = (_hooks: Hooks<D>): void => undefined;

  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow,
    headers,
  } = useTable(
    {
      columns,
      data,
      manualFilters: true,
      manualSortBy,
      getRowId:
        rowsConfig != null && rowsConfig.rowIdExtractor != null
          ? rowsConfig.rowIdExtractor
          : undefined,
      initialState: {
        filters,
        expanded: pipe(
          fromUndefinedable(expandedRows),
          getOrElse(() => ({} as Record<IdType<D>, boolean>))
        ),
        sortBy: pipe(
          fromUndefinedable(sortBy),
          getOrElse(() => [])
        ),
        selectedRowIds: pipe(
          fromUndefinedable(selectedRows),
          getOrElse(() => ({} as Record<IdType<D>, boolean>))
        ),
      },
      stateReducer: (newState, action) => {
        switch (action.type as TableActionType) {
          case 'toggleRowSelected':
          case 'toggleAllRowsSelected':
            pipe(
              fromUndefinedable(onSelectedRowsChange),
              getOrElse(() => noop),
              invokeWith(newState.selectedRowIds)
            );
            break;
          case 'toggleSortBy':
            pipe(
              fromUndefinedable(onSortByChange),
              getOrElse(() => noop),
              invokeWith(newState.sortBy)
            );
            break;
          case 'setFilter':
            pipe(
              fromUndefinedable(onFiltersChange),
              getOrElse(() => noop),
              invokeWith(newState.filters)
            );
            break;
          case 'toggleRowExpanded':
            pipe(
              fromUndefinedable(onExpandedRowsChange),
              getOrElse(() => noop),
              invokeWith(newState.expanded)
            );
            break;
          default:
            break;
        }
        return newState;
      },
      useControlledState,
      customRowExpandable:
        expansion !== undefined ? expansion.rowExpandable : always(false),
    },
    ...pipe(
      [
        filters !== undefined && onFiltersChange !== undefined
          ? useFilters
          : emptyHook,
        useSortBy,
        expansion !== undefined ? useExpanded : emptyHook,
        expansion !== undefined ? useRowExpansionUI : emptyHook,
        selectable === true ? useRowSelect : emptyHook,
        selectable === true ? useRowSelectionUI : emptyHook,
      ],
      reject(equal(emptyHook))
    )
  );

  const isMultipleLevelHeader = !!headers.filter(
    (header) => header.columns !== undefined
  ).length;

  const tableProps = getTableProps();
  const bodyProps = getTableBodyProps();

  // We are using headerGroups[0] here because currently we don't support multiple header groups
  const [columnLefts, columnRefs] = useColumnLefts<HTMLTableHeaderCellElement>(
    headerGroups[0]?.headers.length
  );
  // Column divider divides the sticky and scrollable parts of the table.
  // We want to stick expansion/selection column and the first column after expansion/selection column.
  // Since expansion/selection column does NOT have accessor, the first column with accessor will be the divider.
  const columnDividerIndex =
    headerGroups[0] !== undefined
      ? headerGroups[0].headers.findIndex((col) => col.accessor !== undefined)
      : 0;

  const [horizontallyScrollable, setHorizontallyScrollable] = useState(false);
  const [tableWrapperElement, setTableWrapperElement] =
    useState<HTMLDivElement | null>(null);
  useResizeObserver(({ clientWidth, scrollWidth }) => {
    setHorizontallyScrollable(clientWidth < scrollWidth);
  }, tableWrapperElement);

  const isHorizontallySticky = useMemo(
    () => (columnIndex: number) =>
      horizontallySticky &&
      horizontallyScrollable &&
      columnIndex <= columnDividerIndex,
    [horizontallySticky, columnDividerIndex, horizontallyScrollable]
  );
  const shouldShowDivider = useMemo(
    () => (columnIndex: number) =>
      horizontallySticky &&
      horizontallyScrollable &&
      columnIndex === columnDividerIndex,
    [horizontallySticky, columnDividerIndex, horizontallyScrollable]
  );

  return (
    <Spinner loading={loading}>
      <StyledTableWrapper
        themeSticky={sticky}
        id={id}
        className={className}
        style={{ ...style, ...useCss(sx) }}
        data-test-id={dataTestId}
        ref={setTableWrapperElement}
      >
        <StyledTable
          style={tableProps.style}
          className={tableProps.className}
          role={tableProps.role}
          themeFixedLayout={hasFixedLayout(columns)}
        >
          <StyledTHead>
            {headerGroups.map((headerGroup: HeaderGroup<D>) => {
              const headerGroupProps = headerGroup.getHeaderGroupProps();
              return (
                <tr key={headerGroupProps.key}>
                  {headerGroup.headers.map((column, columnIndex) => {
                    const headerProps = column.getHeaderProps(
                      column.getSortByToggleProps()
                    );

                    const hasFilterInput = pipe(
                      fromUndefinedable(filters),
                      flatMap(find((filter) => filter.id === column.id)),
                      map(
                        ({ value }) =>
                          isDefined(value) &&
                          !(typeof value === 'string' && value === '')
                      ),
                      getOrElse(() => false)
                    );
                    // TODO: this logic just work with 2 levels header. Need another logic to handle it correctly.
                    const hasBorderRight = !!headers.filter((header) => {
                      const childrenHeaderLength = header.columns?.length;
                      if (!childrenHeaderLength) return false;

                      const lastChildrenHeader =
                        header.columns[childrenHeaderLength - 1];

                      return lastChildrenHeader.id === column.id;
                    }).length;

                    return (
                      <TableTH
                        // XXX: Intentionally having spreading props to accept custom props from react-table
                        {...headerProps}
                        key={headerProps.key}
                        sortingProps={{
                          toggleSortBy: column.toggleSortBy,
                          sortable: column.canSort,
                          sorted: column.isSorted,
                          sortedDesc: column.isSortedDesc,
                        }}
                        sticky={sticky}
                        displayAtBreakpoint={column.displayAtBreakpoint}
                        filterable={
                          column.canFilter === true &&
                          column.Filter !== undefined
                        }
                        renderFilter={(props: {
                          onClose: () => void;
                        }): ReactNode => column.render('Filter', props)}
                        hasFilterInput={hasFilterInput}
                        data-test-id={`table__${headerProps.key}`}
                        align={column.align}
                        themeWidth={column.width}
                        themeHorizontallySticky={isHorizontallySticky(
                          columnIndex
                        )}
                        hasBorderRight={
                          (isMultipleLevelHeader && column.depth === 0) ||
                          hasBorderRight
                        }
                        themeLeft={columnLefts[columnIndex]}
                        themeShowDivider={shouldShowDivider(columnIndex)}
                        ref={columnRefs[columnIndex]}
                      >
                        {column.render('Header')}
                      </TableTH>
                    );
                  })}
                </tr>
              );
            })}
          </StyledTHead>
          <StyledTBody
            style={bodyProps.style}
            className={bodyProps.className}
            role={bodyProps.role}
          >
            {rows.map((row: Row<D>) => {
              prepareRow(row);
              const rowProps = row.getRowProps();
              const rowClassName =
                rowsConfig !== undefined &&
                rowsConfig.generateClassName !== undefined
                  ? rowsConfig.generateClassName(row)
                  : undefined;

              return (
                <React.Fragment key={rowProps.key}>
                  <tr
                    className={rowClassName}
                    data-test-id={`table__${rowProps.key}`}
                  >
                    {row.cells.map((cell, cellIndex) => {
                      const cellProps = cell.getCellProps();

                      return (
                        <StyledTD
                          key={cellProps.key}
                          data-test-id={`table__${cellProps.key}`}
                          themeAlign={cell.column.align}
                          themeDisplayAtBreakpoint={
                            cell.column.displayAtBreakpoint
                          }
                          themeHorizontallySticky={isHorizontallySticky(
                            cellIndex
                          )}
                          themeLeft={columnLefts[cellIndex]}
                          themeShowDivider={shouldShowDivider(cellIndex)}
                        >
                          {cell.render('Cell')}
                        </StyledTD>
                      );
                    })}
                  </tr>
                  {expansion !== undefined &&
                    row.isExpanded === true &&
                    expansion.expandedRowRenderer(row.original)}
                </React.Fragment>
              );
            })}
          </StyledTBody>
        </StyledTable>
        {rows.length === 0 && noData !== undefined && (
          <StyledEmptyTableContent>{noData}</StyledEmptyTableContent>
        )}
      </StyledTableWrapper>
      {pipe(
        fromUndefinedable(pagination),
        map((paginationValue) => (
          <StyledPaginationWrapper>
            <Pagination
              current={paginationValue.current}
              total={paginationValue.total}
              onChange={
                onPaginationChange !== undefined ? onPaginationChange : noop
              }
            />
            {pipe(
              fromUndefinedable(itemsPerPage),
              map((ipp) => (
                <StyledItemsPerPageSelect
                  size="small"
                  onChange={(val): void => {
                    if (
                      val !== undefined &&
                      onItemsPerPageChange !== undefined
                    ) {
                      onItemsPerPageChange(val);
                    }
                  }}
                  options={ipp.options}
                  value={ipp.value}
                  optionMenuStyle={{ width: 'auto' }}
                />
              )),
              getOrElse(() => null)
            )}
          </StyledPaginationWrapper>
        )),
        getOrElse(() => null)
      )}
    </Spinner>
  );
}

export default Table;
