import React, { useRef, useCallback } from 'react';
import type { ReactElement } from 'react';
import { useCss } from '../../../utils/hooks';

import Icon from '../../Icon';
import Typography from '../../Typography';
import Tooltip from '../../Tooltip';
import { DropzoneWrapper, HiddenInput } from './StyledDragAndDrop';
import { isValidExtension } from '../utils';
import { fromUndefinedable, getOrElse, map } from '../../../fp/Option';
import { invoke, invokeWith, noop, pipe } from '../../../fp/function';
import { reduce } from '../../../fp/Array';
import { match, right, left } from '../../../fp/Either';
import type { CommonProps } from '../../common';
import type { Either } from '../../../fp/Either';

export interface DragAndDropProps extends CommonProps {
  /**
   * A comma-separated list of one or more file types, or [unique file type specifiers](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept#unique_file_type_specifiers), describing which file types to allow.
   */
  accept?: string;
  /**
   * Description for accepted files.
   */
  description?: string | ReactElement;
  /**
   * Disabled state.
   */
  disableConfig?: {
    disabled: boolean;
    reason: string;
  };
  /**
   * Maximum file size (in `bytes`).
   */
  maxSize?: number;
  /**
   * Allow to drag and drop/select multiple files.
   */
  multiple?: boolean;
  /**
   * Event handler receiving accepted files.
   */
  onAccept?: (files: File[]) => void;
  /**
   * Event handler receiving rejected files.
   */
  onReject?: (
    rejectedFiles: {
      file: File;
      reason: 'size-limit-exceeded' | 'format-not-allowed';
    }[]
  ) => void;
  /**
   * Displayed text.
   */
  text?: string | ReactElement;
}

const DEFAULT_MAX_SIZE = 100 * 1024 * 1024 * 1024; // 100GBs

const preventDefaultEvent = (e: React.MouseEvent<HTMLElement>): void => {
  e.preventDefault();
};

const stopPropagationEvent = (e: React.MouseEvent<HTMLElement>): void => {
  e.stopPropagation();
};

const eitherValidOrInvalid =
  (allowedExtensions: string[], allowedMaxSize: number) =>
  (
    file: File
  ): Either<File, [File, 'format-not-allowed' | 'size-limit-exceeded']> => {
    const hasValidExtension = allowedExtensions.some(
      isValidExtension(file.name, file.type)
    );
    if (allowedExtensions.length > 0 && hasValidExtension === false) {
      return right([file, 'format-not-allowed']);
    }
    if (file.size > allowedMaxSize) {
      return right([file, 'size-limit-exceeded']);
    }
    return left(file);
  };

const DragAndDrop = ({
  text,
  description,
  disableConfig = { disabled: false, reason: '' },
  onAccept,
  onReject,
  multiple = false,
  accept,
  maxSize,
  id,
  className,
  style,
  sx = {},
  'data-test-id': dataTestId,
}: DragAndDropProps): ReactElement => {
  const isActive = !disableConfig.disabled;
  const inputRef = useRef<HTMLInputElement>(null);
  const onDropzoneClick = useCallback(() => {
    if (inputRef.current !== null) {
      inputRef.current.value = '';
      inputRef.current.click();
    }
  }, []);

  const allowedExtensions = React.useMemo(
    () =>
      pipe(
        accept,
        fromUndefinedable,
        map((acc) => acc.split(',').map((i) => i.trim())),
        getOrElse(() => [])
      ),
    [accept]
  );

  const allowedMaxSize = React.useMemo(
    () =>
      pipe(
        maxSize,
        fromUndefinedable,
        getOrElse(() => DEFAULT_MAX_SIZE)
      ),
    [maxSize]
  );

  const onChanged = React.useCallback(
    (files: File[]) => {
      const { validFiles, invalidFiles } = pipe(
        multiple === true ? files : files.slice(0, 1),
        reduce(
          (
            acc: {
              invalidFiles: {
                file: File;
                reason: 'format-not-allowed' | 'size-limit-exceeded';
              }[];
              validFiles: File[];
            },
            cur: File
          ) =>
            pipe(
              cur,
              eitherValidOrInvalid(allowedExtensions, allowedMaxSize),
              match(
                (file) => ({ ...acc, validFiles: [...acc.validFiles, file] }),
                ([file, reason]) => ({
                  ...acc,
                  invalidFiles: [...acc.invalidFiles, { file, reason }],
                })
              )
            ),
          { validFiles: [], invalidFiles: [] }
        )
      );
      if (validFiles.length > 0) {
        pipe(
          onAccept,
          fromUndefinedable,
          getOrElse(() => noop),
          invokeWith(validFiles)
        );
      }

      if (invalidFiles.length > 0) {
        pipe(
          onReject,
          fromUndefinedable,
          getOrElse(() => noop),
          invokeWith(invalidFiles)
        );
      }
    },
    [multiple, allowedMaxSize, allowedExtensions, onAccept, onReject]
  );
  const onDrop = useCallback(
    (e) => {
      preventDefaultEvent(e);
      pipe(e.dataTransfer.files, Array.from, invoke(onChanged));
    },
    [onChanged]
  );
  const onInputChange = useCallback(
    (e) => {
      pipe(e.target.files, Array.from, invoke(onChanged));
    },
    [onChanged]
  );

  const dropZone = (
    <DropzoneWrapper
      onClick={isActive ? onDropzoneClick : noop}
      onDragOver={isActive ? preventDefaultEvent : noop}
      onDragEnter={isActive ? preventDefaultEvent : noop}
      onDragLeave={isActive ? preventDefaultEvent : noop}
      onDrop={isActive ? onDrop : noop}
      className={className}
      style={{ ...style, ...useCss(sx) }}
      data-test-id={dataTestId}
      themeActive={isActive}
    >
      <div>
        {text !== undefined && (
          <div>
            <Icon
              icon="upload-outlined"
              size="xlarge"
              intent={isActive ? 'primary' : 'disabled-text'}
            />
            <Typography.Text intent={isActive ? 'main' : 'disabled'}>
              {text}
            </Typography.Text>
          </div>
        )}
        {description !== undefined && (
          <Typography.Text intent={isActive ? 'subdued' : 'disabled'}>
            {description}
          </Typography.Text>
        )}
      </div>
      <HiddenInput
        type="file"
        disabled={disableConfig.disabled}
        ref={inputRef}
        onChange={onInputChange}
        multiple={multiple}
        accept={accept}
        onClick={stopPropagationEvent}
        id={id}
      />
    </DropzoneWrapper>
  );

  return isActive ? (
    dropZone
  ) : (
    <Tooltip
      target={dropZone}
      content={disableConfig.reason}
      placement="bottom"
      sx={{ width: '100%' }}
    />
  );
};

export default DragAndDrop;
