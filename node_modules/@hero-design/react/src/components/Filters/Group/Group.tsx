import React, {
  useState,
  ReactElement,
  useMemo,
  ReactNode,
  useCallback,
  Children,
} from 'react';
import Dropdown from '../../Dropdown';
import { IconName } from '../../Icon';
import { FilterSize, FilterValue } from '../types';
import { useFiltersContext } from '../FiltersContext';
import { FilterProps } from './Filter';
import GroupContext from './GroupContext';
import { hasSelection, getCaretIcon } from '../utils';
import DropdownButton from '../DropdownButton';
import {
  GroupWrapper,
  DropdownContentWrapper,
  WideDropdownContentWrapper,
} from './StyledGroupFilter';
import MediaQuery from '../../MediaQuery';

export type RenderProps<T extends FilterValue> = {
  closeDropdown: () => void;
  commit: (v?: Partial<T>) => void;
  commitAll: () => void;
  dirty: boolean;
  reset: (v?: Partial<T>) => void;
  resetAll: () => void;
  size: FilterSize;
};

const MAX_VERTIVAL_FILTERS = 5;

export interface FilterGroupProps<T extends FilterValue> {
  bottomAddon?: (renderProps: RenderProps<T>) => ReactNode;
  children:
    | ReactElement<FilterProps<T, keyof T>>
    | ReactElement<FilterProps<T, keyof T>>[];
  icon?: IconName | ReactElement;
  isApplyChangeOnClose?: boolean;
  noCaret?: boolean;
  onClose?: (renderProps: RenderProps<T>) => void;
  text?: string;
  'data-test-id'?: string;
}

const Group = <T extends FilterValue>({
  text,
  icon,
  noCaret = false,
  children,
  onClose,
  isApplyChangeOnClose = true,
  bottomAddon,
  'data-test-id': dataTestId,
}: FilterGroupProps<T>) => {
  const [openDropdown, setOpenDropdown] = useState(false);

  const [filterKeys, setFilterKeys] = useState<Set<string>>(new Set());

  const addFilterKey = useCallback(
    (key: string) => {
      setFilterKeys((prev) => {
        const newSet = new Set(prev);
        newSet.add(key);
        return newSet;
      });
    },
    [setFilterKeys]
  );

  const removeFilterKey = useCallback(
    (key: string) => {
      setFilterKeys((prev) => {
        const newSet = new Set(prev);
        newSet.delete(key);
        return newSet;
      });
    },
    [setFilterKeys]
  );

  const {
    value,
    defaultValue,
    onChange,
    valueState,
    onValueStateChange,
    commitAll,
    resetAll,
    size,
  } = useFiltersContext();

  const commit = useCallback(
    (v?: Partial<T>) => {
      if (v !== undefined) {
        onChange({
          ...value,
          ...v,
        });
        onValueStateChange({
          ...value,
          ...v,
        });
      } else {
        const valueStateForKeys = Array.from(filterKeys).reduce(
          (acc, key) => ({
            ...acc,
            [key]: valueState[key],
          }),
          {}
        );
        onChange({
          ...value,
          ...valueStateForKeys,
        });
      }
    },
    [onChange, onValueStateChange, filterKeys, value, valueState]
  );

  const dirty = useMemo(() => {
    return Array.from(filterKeys).some((key) => {
      return valueState[key] !== defaultValue?.[key];
    });
  }, [filterKeys, valueState, valueState]);

  const reset = useCallback(
    (v?: Partial<T>) => {
      if (v !== undefined) {
        onChange({
          ...value,
          ...v,
        });
        onValueStateChange({
          ...valueState,
          ...v,
        });
      } else {
        const resetValueForKeys = Array.from(filterKeys).reduce(
          (acc, key) => ({
            ...acc,
            [key]: defaultValue?.[key],
          }),
          {}
        );
        onChange({
          ...valueState,
          ...resetValueForKeys,
        });
        onValueStateChange({
          ...valueState,
          ...resetValueForKeys,
        });
      }
    },
    [onChange, onValueStateChange, filterKeys, value, valueState, defaultValue]
  );

  const renderProps: RenderProps<T> = {
    commit,
    reset,
    dirty,
    resetAll,
    commitAll,
    closeDropdown: () => setOpenDropdown(false),
    size,
  };

  const active = useMemo(
    () => Array.from(filterKeys).some((k) => hasSelection(value[k])),
    [filterKeys, value]
  );

  const contextValue = useMemo(
    () => ({
      filterKeys,
      addFilterKey,
      removeFilterKey,
    }),
    [filterKeys, addFilterKey, removeFilterKey]
  );

  const numberOfFilters = Children.count(children);

  return (
    <GroupContext.Provider value={contextValue}>
      <GroupWrapper>
        <Dropdown
          keepContentMounted
          open={openDropdown}
          onClose={() => {
            setOpenDropdown(false);
            onClose?.(renderProps);
            if (isApplyChangeOnClose && renderProps.dirty) {
              renderProps.commit();
            }
          }}
          content={
            <DropdownContentWrapper>
              {numberOfFilters <= MAX_VERTIVAL_FILTERS && children}
              {numberOfFilters > MAX_VERTIVAL_FILTERS && (
                <MediaQuery>
                  {(screenSize) => {
                    switch (screenSize) {
                      case 'small':
                      case 'medium':
                        return children;
                      case 'large':
                        return (
                          <WideDropdownContentWrapper
                            themeSize="large"
                            data-test-id="large-wide-content-wrapper"
                          >
                            {children}
                          </WideDropdownContentWrapper>
                        );
                      case 'xlarge':
                        return (
                          <WideDropdownContentWrapper
                            themeSize="xlarge"
                            data-test-id="xlarge-wide-content-wrapper"
                          >
                            {children}
                          </WideDropdownContentWrapper>
                        );
                    }
                  }}
                </MediaQuery>
              )}
              {bottomAddon?.(renderProps)}
            </DropdownContentWrapper>
          }
          target={
            <DropdownButton
              size={size}
              data-test-id={dataTestId}
              active={active}
              text={text}
              leftIcon={icon}
              rightIcon={
                noCaret === true ? undefined : getCaretIcon(openDropdown)
              }
              onClick={() => setOpenDropdown((v) => !v)}
            />
          }
        />
      </GroupWrapper>
    </GroupContext.Provider>
  );
};

Group.displayName = 'Filters.Group';

export default Group;
