import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  ReactNode,
} from 'react';
import {
  useFloating,
  offset,
  arrow,
  flip,
  autoUpdate,
} from '@floating-ui/react-dom';
import { useTheme } from 'styled-components';
import type { ReactElement } from 'react';
import { useCss } from '../../utils/hooks';

import { TooltipContainer, TooltipWrapper, Arrow } from './StyledTooltip';
import Portal from '../Portal';
import { getDefaultPortalContainer } from '../../utils/getDefaultPortalContainer';
import type { CommonProps } from '../common';

type Placement = 'top' | 'bottom' | 'right' | 'left';
export interface TooltipProps extends CommonProps {
  /**
   * Content of tooltip.
   */
  content: ReactNode;
  /**
   * The number of milliseconds to wait before showing the tooltip.
   */
  delay?: number;
  /**
   * Whether the tooltip content can be interactive, allowing you to hover over and click inside it.
   */
  interactive?: boolean;
  /**
   * Milliseconds for interaction timeout, this only takes effect when `interactive` is enabled.
   */
  interactiveTimeout?: number;
  /**
   * Open state of tooltip. Use this if you wish to control the tooltip state. Also, the hover interaction and interative tooltip will be disabled when this prop is set.
   */
  open?: boolean;
  /**
   * Position of tooltip.
   */
  placement?: Placement;
  /**
   The target where tooltip is relatively placed to.
  */
  target: string | ReactElement;
  /**
   Whether or not to show Tooltip when hovering the target.
  */
  visible?: boolean;
  /**
   * If `true`, the tooltip element will be rendered using Portal. Otherwise, it will be rendered directly to the current tree
   */
  withPortal?: boolean;
  /**
   * Theme status styles.
   */
  variant?: 'dark' | 'light';
}

const FALLBACK_PLACEMENT_MAP: {
  bottom: 'top';
  left: 'right';
  right: 'left';
  top: 'bottom';
} = {
  bottom: 'top',
  top: 'bottom',
  left: 'right',
  right: 'left',
};

const Tooltip = ({
  content,
  placement: placementFromProps = 'top',
  target,
  interactive = false,
  interactiveTimeout = 200,
  id,
  className,
  style,
  withPortal = false,
  sx = {},
  'data-test-id': dataTestId,
  open: controlledOpen,
  visible = true,
  variant = 'dark',
  delay,
}: TooltipProps): ReactElement => {
  const [containerElement, setContainerElement] =
    useState<HTMLDivElement | null>(null);
  const [tooltipElement, setTooltipElement] = useState<HTMLDivElement | null>(
    null
  );
  const [arrowElement, setArrowElement] = useState<HTMLDivElement | null>(null);
  const [isAnimatedEnd, setIsAnimationEnd] = useState<boolean>(true);
  const [open, setOpen] = useState<boolean>(
    controlledOpen !== undefined ? controlledOpen : false
  );
  const mouseEnteredContentRef = useRef<boolean>(false);
  const interactiveTimerId = useRef<number>();
  const theme = useTheme();

  const {
    update,
    middlewareData,
    floatingStyles,
    placement: uiFloatingPlacement,
  } = useFloating({
    elements: { reference: containerElement, floating: tooltipElement },
    strategy: 'fixed',
    placement: placementFromProps,
    middleware: [
      offset(theme.__hd__.tooltip.space.margin),
      flip({
        fallbackPlacements: [FALLBACK_PLACEMENT_MAP[placementFromProps]],
      }),
      arrow({ element: arrowElement }),
    ],
    whileElementsMounted: autoUpdate,
  });

  // uiFloatingPlacement returns top, left, right, bottom and top-start, top-end,..
  const placement = uiFloatingPlacement.split('-')[0] as Placement;

  const openTooltip = useCallback(() => {
    if (controlledOpen !== undefined) {
      return;
    }

    setOpen(true);
  }, [controlledOpen, setOpen]);

  const closeTooltip = useCallback(() => {
    if (controlledOpen !== undefined) {
      return;
    }

    setOpen(false);
  }, [controlledOpen, setOpen]);

  const delayCloseTooltipContent = useCallback(() => {
    if (interactive === true) {
      interactiveTimerId.current = window.setTimeout(() => {
        if (mouseEnteredContentRef.current === false) {
          closeTooltip();
        }
      }, interactiveTimeout);
    } else {
      interactiveTimerId.current = undefined;
      closeTooltip();
    }
  }, [interactive, interactiveTimeout, closeTooltip]);

  useEffect(() => {
    if (tooltipElement !== null) {
      tooltipElement.addEventListener('mouseleave', () => {
        mouseEnteredContentRef.current = false;
      });

      tooltipElement.addEventListener('mouseenter', () => {
        mouseEnteredContentRef.current = true;
      });
    }
  }, [tooltipElement]);

  useEffect(() => {
    containerElement?.addEventListener('mouseleave', delayCloseTooltipContent);
    tooltipElement?.addEventListener('mouseleave', delayCloseTooltipContent);

    return () => {
      containerElement?.removeEventListener(
        'mouseleave',
        delayCloseTooltipContent
      );
      tooltipElement?.removeEventListener(
        'mouseleave',
        delayCloseTooltipContent
      );
    };
  }, [containerElement, delayCloseTooltipContent, tooltipElement]);

  useEffect(() => {
    update?.();
  }, [content, update]);

  useEffect(() => {
    if (controlledOpen !== undefined) {
      setOpen(controlledOpen);
    }
  }, [controlledOpen, setOpen]);

  useEffect(() => {
    return () => window.clearTimeout(interactiveTimerId.current);
  }, []);

  const onMouseEnter = useCallback(() => {
    if (delay) {
      setIsAnimationEnd(false);
    }
    openTooltip();
  }, [delay, openTooltip]);

  return (
    <TooltipContainer
      ref={setContainerElement}
      onMouseEnter={onMouseEnter}
      onTouchStart={onMouseEnter}
      id={id}
      className={className}
      style={{ ...style, ...useCss(sx) }}
      data-test-id={dataTestId}
    >
      {target}
      {open === true && visible === true && (
        <Portal withPortal={withPortal} container={getDefaultPortalContainer()}>
          <TooltipWrapper
            style={{
              ...floatingStyles,
              visibility: isAnimatedEnd ? 'visible' : 'hidden',
            }}
            ref={setTooltipElement}
            variant={variant}
            themeDelay={delay}
            onAnimationEnd={() => {
              setIsAnimationEnd(true);
            }}
          >
            {content}
            <Arrow
              ref={setArrowElement}
              style={{
                top: middlewareData.arrow?.y || '',
                left: middlewareData.arrow?.x || '',
                [FALLBACK_PLACEMENT_MAP[placement]]: `-${
                  (arrowElement?.offsetWidth || 0) / 2
                }px`,
              }}
              variant={variant}
            />
          </TooltipWrapper>
        </Portal>
      )}
    </TooltipContainer>
  );
};

export default Tooltip;
