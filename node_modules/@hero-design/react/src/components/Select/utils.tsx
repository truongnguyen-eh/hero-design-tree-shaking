import { fromNullable, map, getOrElse } from '../../fp/Option';
import { pipe } from '../../fp/function';
import type { GroupedOption, BaseOption } from './types';

const checkAtBottom = (element: HTMLDivElement | null): boolean | undefined =>
  pipe(
    fromNullable(element),
    // Fix issue with scrollTop on some browsers scale being in different values
    map((el) => {
      return el.scrollHeight - Math.ceil(el.scrollTop) === el.clientHeight;
    }),
    getOrElse(() => undefined)
  );

const getItemOffsetTop = (itemEl: HTMLLIElement | null): number | undefined =>
  pipe(
    fromNullable(itemEl),
    map((el) => el.offsetTop),
    getOrElse(() => undefined)
  );

const isGroupedOptions = <V extends string | number, T extends BaseOption<V>>(
  options: T[] | GroupedOption<V, T>[]
): options is GroupedOption<V, T>[] => {
  const firstOption = options[0];
  return (
    firstOption !== undefined &&
    (firstOption as GroupedOption<V, T>).category !== undefined
  );
};

const mapOptions = <V extends string | number, T extends BaseOption<V>>(
  options: T[] | GroupedOption<V, T>[]
): GroupedOption<V, T>[] => {
  if (isGroupedOptions(options)) {
    return options;
  }

  return [{ category: '', options }];
};

const optionPredicate =
  <V extends string | number, T extends BaseOption<V>>(query?: string) =>
  (option: T): boolean => {
    if (query === undefined) {
      return true;
    }

    const matchedOptionText = option.text
      .toLowerCase()
      .includes(query.toLowerCase());

    const matchedOptionHelpText =
      option.helpText?.toLowerCase().includes(query.toLowerCase()) ?? false;

    return matchedOptionText || matchedOptionHelpText;
  };

const filterGroupedOptions = <
  V extends string | number,
  T extends BaseOption<V>
>(
  predicate: (opt: T) => boolean,
  groupedOptions: GroupedOption<V, T>[]
): GroupedOption<V, T>[] =>
  groupedOptions
    .map((groupedOpt: GroupedOption<V, T>) => ({
      ...groupedOpt,
      options: groupedOpt.options.filter(predicate),
    }))
    .filter((groupedOpt: GroupedOption<V, T>) => groupedOpt.options.length > 0);

const getAccumulatedIndex = <
  V extends string | number,
  T extends BaseOption<V>
>(
  options: GroupedOption<V, T>[],
  catIndex: number
): number => {
  if (catIndex === 0) {
    return 0;
  }

  return options
    .slice(0, catIndex)
    .reduce((acc, groupedOpt) => acc + groupedOpt.options.length, 0);
};

const findNonDisabledItemIdx = <
  V extends string | number,
  T extends BaseOption<V>
>(
  items: T[],
  currIdx: number,
  type: 'prev' | 'next'
): number => {
  let idx = currIdx;
  switch (type) {
    case 'prev':
      do {
        idx -= 1;
        if (idx < 0) {
          idx = items.length - 1;
        }
      } while (items[idx].disabled && idx !== currIdx);
      break;
    case 'next':
      do {
        idx += 1;
        if (idx >= items.length) {
          idx = 0;
        }
      } while (items[idx].disabled && idx !== currIdx);
      break;
  }

  return idx;
};

export {
  isGroupedOptions,
  checkAtBottom,
  getItemOffsetTop,
  mapOptions,
  filterGroupedOptions,
  optionPredicate,
  getAccumulatedIndex,
  findNonDisabledItemIdx,
};
