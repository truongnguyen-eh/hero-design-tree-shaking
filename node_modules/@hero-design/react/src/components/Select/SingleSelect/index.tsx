import { useCombobox } from 'downshift';
import React, { useState, useCallback, useMemo, useEffect } from 'react';
import type { ReactElement, ReactNode, CSSProperties, FocusEvent } from 'react';
import { useCss, useResizeObserver } from '../../../utils/hooks';
import { SelectWrapper } from '../StyledSelect';
import { map as arrayMap, flat } from '../../../fp/Array';
import {
  mapOptions,
  optionPredicate as defaultOptionPredicate,
  filterGroupedOptions,
  findNonDisabledItemIdx,
} from '../utils';
import { pipe, noop } from '../../../fp/function';

import Dropdown from '../../Dropdown';
import HiddenInput from './HiddenInput';
import OptionList from './OptionList';
import QueryInput from './QueryInput';
import type { CommonProps } from '../../common';
import type { IconName } from '../../Icon';
import type { BaseOption, GroupedOption } from '../types';

export interface SelectProps<V extends string | number, T extends BaseOption<V>>
  extends CommonProps {
  /**
   * HTML ID of an element that should be used as the label (for assistive tech).
   */
  'aria-labelledby'?: string;
  /**
   * Specify the [automated assistance](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) in filling out form field values by the browser.
   */
  autoComplete?: string;
  /**
   * Allow to clear value after selecting an item.
   */
  clearable?: boolean;
  /**
   * Whether the select is disabled.
   */
  disabled?: boolean;
  /**
   * Whether the input is invalid.
   */
  invalid?: boolean;
  /**
   * Loading state of Select, which will render a spinner at bottom of the option list.
   */
  loading?: boolean;
  /**
   * Name of <input> element, is used to refer to the form data for submission.
   */
  name?: string;
  /**
   * Content to render when filtering items returns zero results.
   */
  noResults?: ReactNode;
  /**
   * Blur event handler.
   */
  onBlur?: (e: FocusEvent<HTMLInputElement>) => void;
  /**
   * onChange event handler.
   */
  onChange: (value?: V) => void;
  /**
   * Callback to allow to create new option when option not found based on query (only when the callback is defined).
   */
  onCreateNewOption?: (optionText: string) => void;
  /**
   * Focus event handler.
   */
  onFocus?: (e: FocusEvent<HTMLInputElement>) => void;
  /**
   * Event handler on key down of input.
   */
  onKeyDown?: (e: React.KeyboardEvent) => void;
  /**
   * Event handler on key up of input.
   */
  onKeyUp?: (e: React.KeyboardEvent) => void;
  /**
   * Callback invoked when the query string changes.
   */
  onQueryChange?: (query?: string) => void;
  /**
   * Handle scroll event when scrolling to the bottom of the option list.
   */
  onScrollListToBottom?: () => void;
  /**
   * Additonal inline style for option menu dropdown.
   */
  optionMenuStyle?: CSSProperties;
  /**
   * Customise option renderer.
   */
  optionRenderer?: ({
    option,
    index,
  }: {
    index: number;
    option: T;
  }) => ReactElement;
  /**
   * Customise option predicater.
   */
  optionPredicate?: (query?: string) => (option: T) => boolean;
  /**
   * An array of (grouped) options to be selected.
   *
   * The generic parameter T should extend BaseOption:
   *
   * type BaseOption = {
   *   disabled?: boolean;
   *   helpText?: string;
   *   text: string;
   *   value: string | number;
   * };
   *
   * type GroupedOption<T> = {
   *   category: string;
   *   options: T[];
   * };
   */
  options: Array<GroupedOption<V, T>> | Array<T>;
  /**
   * Placeholder text in the absence of any value.
   */
  placeholder?: string;
  /**
   * Name of Icon or an Icon element to render on the left side of the input.
   */
  prefix?: IconName | ReactElement;
  /**
   * Query string to filter options. This value is controlled: its state if defined must be managed externally.
   */
  query?: string;
  /**
   * Customise selected option renderer.
   */
  selectedOptionRenderer?: ({ option }: { option: T }) => string | ReactElement;
  /**
   * The size of the input box.
   */
  size?: 'small' | 'medium' | 'large';
  /**
   * Current selected value.
   */
  value?: V;
  /**
   * Input ref passing to query input element
   */
  inputRef?: React.Ref<HTMLInputElement>;
}

const Select = <V extends string | number, T extends BaseOption<V>>({
  options,
  value,
  onBlur,
  onChange,
  onFocus,
  query,
  onQueryChange,
  onKeyDown,
  onKeyUp,
  optionRenderer,
  optionPredicate,
  selectedOptionRenderer,
  noResults,
  disabled = false,
  size = 'medium',
  invalid,
  placeholder,
  prefix,
  onScrollListToBottom,
  loading,
  name,
  onCreateNewOption,
  id,
  'aria-labelledby': ariaLabelledBy,
  className,
  style,
  sx = {},
  autoComplete,
  optionMenuStyle,
  clearable = false,
  'data-test-id': dataTestId,
  inputRef,
}: SelectProps<V, T>): ReactElement => {
  const [wrapperElement, setWrapperElement] = useState<HTMLDivElement | null>(
    null
  );
  const [optionMenuWidth, setOptionMenuWidth] = useState<number>();
  const [autoFilled, setAutoFilled] = useState<boolean>(false);
  const [highlightedIndex, setHighlightedIndex] = useState<number>(-1);

  const mappedOptions = useMemo(() => {
    return filterGroupedOptions(
      optionPredicate ? optionPredicate(query) : defaultOptionPredicate(query),
      mapOptions<V, T>(options)
    );
  }, [options, query, optionPredicate]);

  const flatMappedOptions = useMemo(
    () =>
      pipe(
        mappedOptions,
        arrayMap((opt) => opt.options),
        flat
      ),
    [mappedOptions]
  );

  const hasResults = mappedOptions.length > 0;

  const selectedItem = useMemo(
    () => flatMappedOptions.find((item) => item.value === value),
    [flatMappedOptions, value]
  );

  const resizeCallback = useCallback(
    ({ width }) => {
      setOptionMenuWidth(width);
    },
    [setOptionMenuWidth]
  );

  useResizeObserver(resizeCallback, wrapperElement);
  const css = useCss(sx);

  const newOption = { value: '' as V, text: query ?? '' };

  const {
    getInputProps,
    getMenuProps,
    getItemProps,
    isOpen,
    getToggleButtonProps,
  } = useCombobox<BaseOption<V>>({
    items: hasResults === true ? flatMappedOptions : [newOption],
    itemToString: (item): string => (item !== null ? item.text : ''),
    selectedItem: selectedItem ?? null,
    stateReducer: (state, actionAndChanges) => {
      const { changes, type } = actionAndChanges;
      if (type === useCombobox.stateChangeTypes.InputClick) {
        return {
          ...changes,
          isOpen: state.isOpen,
        };
      }

      return {
        ...changes,
      };
    },
    onSelectedItemChange: ({ selectedItem: newItem }): void => {
      if (newItem != null) {
        if (hasResults === false) {
          onCreateNewOption?.(newItem.text);
        } else {
          onChange(newItem.value);
        }
      }
      if (query !== undefined) {
        onQueryChange?.(undefined);
      }
    },
    onStateChange: (state) => {
      if (state.type === useCombobox.stateChangeTypes.InputBlur) {
        if (query !== undefined) {
          onQueryChange?.(undefined);
        }
      }
    },
    highlightedIndex,
    onHighlightedIndexChange: ({
      highlightedIndex: newHighlightedIndex,
      type,
    }) => {
      if (newHighlightedIndex === undefined || newHighlightedIndex === -1) {
        setHighlightedIndex(-1);
        return;
      }

      if (!hasResults || !flatMappedOptions[newHighlightedIndex].disabled) {
        setHighlightedIndex(newHighlightedIndex);
        return;
      }

      if (type === useCombobox.stateChangeTypes.InputKeyDownArrowDown) {
        // find next non-disabled item
        const nextIdx = findNonDisabledItemIdx<V, T>(
          flatMappedOptions,
          newHighlightedIndex,
          'next'
        );
        setHighlightedIndex(nextIdx === newHighlightedIndex ? -1 : nextIdx);
      }

      if (type === useCombobox.stateChangeTypes.InputKeyDownArrowUp) {
        // find previous non-disabled item
        const prevIdx = findNonDisabledItemIdx<V, T>(
          flatMappedOptions,
          newHighlightedIndex,
          'prev'
        );
        setHighlightedIndex(prevIdx === newHighlightedIndex ? -1 : prevIdx);
      }
    },
  });

  useEffect(() => {
    if (autoFilled && query !== undefined && query.length > 0) {
      const autoFilledItem = flatMappedOptions.find(
        (item) => item.text === query
      );

      if (autoFilledItem !== undefined) {
        onChange(autoFilledItem.value);
      }

      setAutoFilled(false);
    }
  }, [autoFilled, query, flatMappedOptions, onChange]);

  const selectInput = (
    <QueryInput
      selectedItem={selectedItem}
      getInputProps={getInputProps}
      isOpen={isOpen}
      selectedOptionRenderer={selectedOptionRenderer}
      id={id}
      aria-labelledby={ariaLabelledBy}
      autoComplete={autoComplete}
      clearable={clearable}
      value={value}
      onChange={onChange}
      query={query}
      onQueryChange={onQueryChange}
      disabled={disabled}
      prefix={prefix}
      loading={loading}
      invalid={invalid}
      placeholder={placeholder}
      size={size}
      onFocus={onFocus}
      onBlur={onBlur}
      onKeyUp={onKeyUp}
      onKeyDown={(e) => {
        if (e.key === 'Unidentified') setAutoFilled(true);
        onKeyDown?.(e);
      }}
      inputRef={inputRef}
    />
  );
  const optionMenu = (
    <OptionList<V, T>
      categories={mappedOptions}
      hasResults={hasResults}
      newOption={newOption}
      selectedItem={selectedItem}
      getItemProps={getItemProps}
      getMenuProps={getMenuProps}
      highlightedIndex={highlightedIndex}
      onScrollListToBottom={onScrollListToBottom}
      onCreateNewOption={onCreateNewOption}
      loading={loading}
      noResults={noResults}
      optionRenderer={optionRenderer}
      style={{ width: optionMenuWidth, ...optionMenuStyle }}
    />
  );

  return (
    <SelectWrapper
      {...getToggleButtonProps({ disabled })}
      className={className}
      style={{ ...style, ...css }}
      data-test-id={dataTestId}
      ref={setWrapperElement}
    >
      {name !== undefined && (
        <HiddenInput
          options={options}
          value={value}
          onChange={onChange}
          onQueryChange={onQueryChange}
          name={name}
        />
      )}
      <Dropdown
        target={selectInput}
        content={optionMenu}
        open={isOpen}
        onClose={noop}
        keepContentMounted
      />
    </SelectWrapper>
  );
};

export default Select;
