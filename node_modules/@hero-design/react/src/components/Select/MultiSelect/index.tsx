import React, { useMemo, useState, useEffect, useCallback } from 'react';
import { useMultipleSelection, useCombobox } from 'downshift';
import type { ReactElement, ReactNode, CSSProperties, FocusEvent } from 'react';
import { useCss, useResizeObserver } from '../../../utils/hooks';
import Dropdown from '../../Dropdown';
import { SelectWrapper } from '../StyledSelect';
import {
  mapOptions,
  optionPredicate as defaultOptionPredicate,
  filterGroupedOptions,
} from '../utils';
import { noop, pipe } from '../../../fp/function';
import { map as arrayMap, flat } from '../../../fp/Array';
import OptionList from './OptionList';
import QueryInput from './QueryInput';
import type { MultiBaseOption, GroupedMultiOption } from '../types';
import type { CommonProps } from '../../common';
import { IconName } from '../../Icon';

export interface MultiSelectProps<
  V extends string | number,
  T extends MultiBaseOption<V>
> extends Omit<CommonProps, 'id'> {
  /**
   * HTML ID of an element that should be used as the label (for assistive tech).
   */
  'aria-labelledby'?: string;
  /**
   * Specify the [automated assistance](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) in filling out form field values by the browser.
   */
  autoComplete?: string;
  /**
   * Whether the select is disabled.
   */
  disabled?: boolean;
  /**
   * Id of <input> element.
   */
  id?: string;
  /**
   * Whether the input is invalid.
   */
  invalid?: boolean;
  /**
   * Loading state of Select, which will render a spinner at bottom of the option list.
   */
  loading?: boolean;
  /**
   * Name of <input> element, is used to refer to the form data for submission.
   */
  name?: string;
  /**
   * Content to render when filtering items returns zero results.
   */
  noResults?: ReactNode;
  /**
   * Blur event handler.
   */
  onBlur?: (e: FocusEvent<HTMLInputElement>) => void;
  /**
   * onChange event handler.
   */
  onChange: (value: V[]) => void;
  /**
   * Callback to allow to create new option when option not found based on query (only when the callback is defined).
   */
  onCreateNewOption?: (optionText: string) => void;
  /**
   * Focus event handler.
   */
  onFocus?: (e: FocusEvent<HTMLInputElement>) => void;
  /**
   * Event handler on key down of input.
   */
  onKeyDown?: (e: React.KeyboardEvent) => void;
  /**
   * Event handler on key up of input.
   */
  onKeyUp?: (e: React.KeyboardEvent) => void;
  /**
   * Callback invoked when the query string changes.
   */
  onQueryChange?: (query?: string) => void;
  /**
   * Handle scroll event when scrolling to the bottom of the option list.
   */
  onScrollListToBottom?: () => void;
  /**
   * Additonal inline style for option menu dropdown.
   */
  optionMenuStyle?: CSSProperties;
  /**
   * Customise option renderer.
   */
  optionRenderer?: (renderOpts: { index: number; option: T }) => ReactElement;
  /**
   * Customise option predicater.
   */
  optionPredicate?: (query?: string) => (option: T) => boolean;
  /**
   * An array of (grouped) options to be selected.
   *
   * The generic parameter T should extend BaseOption:
   *
   * type BaseOption = {
   *   disabled?: boolean;
   *   helpText?: string;
   *   text: string;
   *   value: string | number;
   * };
   *
   * type GroupedOption<T> = {
   *   category: string;
   *   options: T[];
   * };
   */
  options: Array<GroupedMultiOption<V, T>> | Array<T>;
  /**
   * Placeholder text in the absence of any value.
   */
  placeholder?: string;
  /**
   * Name of Icon or an Icon element to render on the left side of the input.
   */
  prefix?: IconName | ReactElement;
  /**
   * Query string to filter options. This value is controlled: its state if defined must be managed externally.
   */
  query?: string;
  /**
   * Customise selected option renderer.
   */
  selectedOptionRenderer?: (renderOpts?: {
    option: T;
  }) => string | ReactElement;
  /**
   * The size of the input box.
   */
  size?: 'small' | 'medium' | 'large';
  /**
   * Current selected value.
   */
  value?: V[];
  /**
   * How select should render selected items.
   */
  variant?: 'basic' | 'compact';
}

const MultiSelect = <V extends string | number, T extends MultiBaseOption<V>>({
  options,
  value,
  onBlur,
  onChange,
  onFocus,
  optionRenderer,
  optionPredicate,
  selectedOptionRenderer,
  disabled = false,
  size = 'medium',
  invalid,
  placeholder,
  prefix,
  onScrollListToBottom,
  onKeyDown,
  onKeyUp,
  loading,
  query,
  onQueryChange,
  noResults,
  name,
  onCreateNewOption,
  id,
  'aria-labelledby': ariaLabelledBy,
  className,
  style,
  sx = {},
  autoComplete,
  optionMenuStyle,
  variant = 'basic',
  'data-test-id': dataTestId,
}: MultiSelectProps<V, T>): ReactElement => {
  const [wrapperElement, setWrapperElement] = useState<HTMLDivElement | null>(
    null
  );
  const [optionMenuWidth, setOptionMenuWidth] = useState<number>();
  const mappedOptions = useMemo(() => {
    return filterGroupedOptions(
      optionPredicate ? optionPredicate(query) : defaultOptionPredicate(query),
      mapOptions<V, T>(options)
    );
  }, [options, query, optionPredicate]);

  const flatMappedOptions = useMemo(
    () =>
      pipe(
        mappedOptions,
        arrayMap((opt) => opt.options),
        flat
      ),
    [mappedOptions]
  );

  const flatOptions = useMemo(
    () =>
      pipe(
        options,
        (opts) => mapOptions<V, T>(opts),
        arrayMap((opt) => opt.options),
        flat
      ),
    [options]
  );

  const hasResults = flatMappedOptions.length > 0;

  const selectedItemsFromValue =
    value !== undefined
      ? value.flatMap((optionVal) => {
          const foundItem = flatOptions.find((opt) => opt.value === optionVal);
          return foundItem !== undefined ? [foundItem] : [];
        })
      : [];

  const { getDropdownProps, selectedItems } = useMultipleSelection({
    selectedItems: selectedItemsFromValue,
  });

  const resizeCallback = useCallback(
    ({ width }) => {
      setOptionMenuWidth(width);
    },
    [setOptionMenuWidth]
  );

  useResizeObserver(resizeCallback, wrapperElement);

  const newOption = { value: '', text: query ?? '' } as T;

  const {
    isOpen,
    getToggleButtonProps,
    getMenuProps,
    getInputProps,
    getItemProps,
    highlightedIndex,
    toggleMenu,
  } = useCombobox({
    items: hasResults === true ? flatMappedOptions : [newOption],
    isItemDisabled: (item) => {
      return item.disabled === true;
    },
    itemToString: (item) => (item ? item.text : ''),
    stateReducer: (_state, actionAndChanges) => {
      const { changes, type } = actionAndChanges;
      const { selectedItem } = changes;
      const isNotRemovable = (item: MultiBaseOption<V>): boolean => {
        return item.value === selectedItem?.value && item.removable === false;
      };
      const updateItems = (): void => {
        if (selectedItem !== undefined && selectedItem !== null) {
          if (value?.includes(selectedItem?.value)) {
            const notRemovableSelectedItem = selectedItems.find(isNotRemovable);
            if (notRemovableSelectedItem) return;
            // Remove item
            onChange(
              selectedItems
                .filter((item) => item.value !== selectedItem.value)
                .map((item) => item.value)
            );
          } else if (!hasResults) {
            onCreateNewOption?.(selectedItem.text);
          } else {
            // Add item
            onChange([
              ...selectedItems.map((item) => item.value),
              selectedItem.value,
            ]);
          }
        }
      };

      const callOnChange = (): void => {
        if (selectedItem) {
          updateItems();
        }
        if (query) {
          onQueryChange?.(undefined);
        }
      };
      switch (type) {
        case useCombobox.stateChangeTypes.InputKeyDownEnter:
          callOnChange();
          return {
            ...changes,
            isOpen: true,
          };
        case useCombobox.stateChangeTypes.InputClick:
          return {
            ...changes,
            isOpen: _state.isOpen, // do not toggle the menu when input is clicked.
          };
        case useCombobox.stateChangeTypes.ItemClick:
          callOnChange();
          return changes;
        default:
          return changes;
      }
    },
  });

  useEffect(() => {
    if (isOpen === false && query !== undefined) toggleMenu();
  }, [query]);

  const selectInput = (
    <QueryInput
      selectedItems={selectedItems}
      getInputProps={getInputProps}
      getDropdownProps={getDropdownProps}
      isOpen={isOpen}
      selectedOptionRenderer={selectedOptionRenderer}
      name={name}
      id={id}
      aria-labelledby={ariaLabelledBy}
      autoComplete={autoComplete}
      onChange={onChange}
      query={query}
      onQueryChange={onQueryChange}
      disabled={disabled}
      prefix={prefix}
      loading={loading}
      invalid={invalid}
      placeholder={placeholder}
      size={size}
      onFocus={onFocus}
      onBlur={onBlur}
      onKeyDown={onKeyDown}
      onKeyUp={onKeyUp}
      variant={variant}
    />
  );
  const css = useCss(sx);

  const optionMenu = (
    <OptionList<V, T>
      categories={mappedOptions}
      hasResults={hasResults}
      newOption={newOption}
      value={value}
      query={query}
      getItemProps={getItemProps}
      getMenuProps={getMenuProps}
      highlightedIndex={highlightedIndex}
      onScrollListToBottom={onScrollListToBottom}
      onCreateNewOption={onCreateNewOption}
      loading={loading}
      noResults={noResults}
      optionRenderer={optionRenderer}
      style={{ width: optionMenuWidth, ...optionMenuStyle }}
    />
  );

  return (
    <SelectWrapper
      {...getToggleButtonProps({ disabled })}
      className={className}
      style={{ ...style, ...css }}
      data-test-id={dataTestId}
      ref={setWrapperElement}
    >
      <Dropdown
        target={selectInput}
        content={optionMenu}
        open={isOpen}
        onClose={noop}
        keepContentMounted
      />
    </SelectWrapper>
  );
};

export default MultiSelect;
