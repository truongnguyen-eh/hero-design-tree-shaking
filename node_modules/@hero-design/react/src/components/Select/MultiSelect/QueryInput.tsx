import React, { useCallback, useMemo } from 'react';
import type {
  UseComboboxReturnValue,
  UseMultipleSelectionReturnValue,
} from 'downshift';
import SuffixIcon from '../SuffixIcon';
import TagInput from '../../TagInput';
import type { MultiBaseOption } from '../types';
import type { MultiSelectProps } from '.';

type QueryInputComponentProps<
  V extends string | number,
  T extends MultiBaseOption<V>
> = {
  selectedItems: T[];
} & Pick<UseComboboxReturnValue<T>, 'getInputProps' | 'isOpen'> &
  Pick<UseMultipleSelectionReturnValue<T>, 'getDropdownProps'> &
  Pick<
    MultiSelectProps<V, T>,
    | 'aria-labelledby'
    | 'selectedOptionRenderer'
    | 'id'
    | 'name'
    | 'autoComplete'
    | 'query'
    | 'onQueryChange'
    | 'onChange'
    | 'prefix'
    | 'disabled'
    | 'loading'
    | 'invalid'
    | 'placeholder'
    | 'size'
    | 'onFocus'
    | 'onBlur'
    | 'onKeyDown'
    | 'onKeyUp'
    | 'variant'
  >;

const getOptionText = <
  V extends string | number,
  T extends MultiBaseOption<V>
>({
  option,
}: {
  option: T;
}) => option.text;

const QueryInput = <V extends string | number, T extends MultiBaseOption<V>>({
  selectedItems,
  getInputProps,
  getDropdownProps,
  isOpen,
  selectedOptionRenderer,
  id,
  autoComplete,
  name,
  onChange,
  query,
  onQueryChange,
  disabled,
  prefix,
  loading,
  invalid,
  placeholder,
  size = 'medium',
  onFocus,
  onBlur,
  onKeyDown,
  onKeyUp,
  variant = 'basic',
  'aria-labelledby': ariaLabelledBy,
}: QueryInputComponentProps<V, T>) => {
  const onItemRemove = useCallback(
    ({ value: removedItemValue }: { value?: string | number }): void => {
      onChange(
        variant === 'compact'
          ? []
          : selectedItems
              .filter((item) => item.value !== removedItemValue)
              .map((item) => item.value)
      );
    },
    [variant, onChange, selectedItems]
  );

  const readonly = onQueryChange === undefined;
  const tagInputValue = query !== undefined ? query : '';
  const tagInputOnChange = useCallback(
    (e) => onQueryChange !== undefined && onQueryChange(e.target.value),
    [onQueryChange]
  );

  const tags = useMemo(() => {
    const selectedOptRenderer = selectedOptionRenderer || getOptionText;

    if (variant === 'compact') {
      const numberOfSelectedItems = selectedItems.length;

      if (numberOfSelectedItems === 0) {
        return [];
      }

      const tagText =
        selectedOptionRenderer !== undefined
          ? `${selectedOptionRenderer()} (${numberOfSelectedItems})`
          : selectedItems
              .map((item) => getOptionText({ option: item }))
              .join(', ');

      return [
        {
          value: tagText,
          text: tagText,
          removable: selectedItems.every((item) =>
            item.removable === undefined ? true : item.removable
          ),
        },
      ];
    }

    return selectedItems.map((item) => ({
      value: item.value,
      text: selectedOptRenderer({ option: item }),
      removable: item.removable === undefined ? true : item.removable,
    }));
  }, [selectedItems, selectedOptionRenderer, variant]);

  return (
    <TagInput
      prefix={prefix}
      suffix={<SuffixIcon loading={loading} open={isOpen} />}
      size={size}
      placeholder={placeholder}
      onRemove={onItemRemove}
      tags={tags}
      {...getInputProps({
        ...getDropdownProps({
          value: undefined, // not yet support input value
          disabled,
        }),
        onFocus,
        onBlur,
        onKeyDown,
        onKeyUp,
        autoComplete,
      })}
      invalid={invalid}
      name={name}
      readonly={readonly}
      value={tagInputValue}
      onChange={tagInputOnChange}
      id={id}
      aria-labelledby={ariaLabelledBy}
      data-test-id="selected-items"
    />
  );
};

export default QueryInput;
