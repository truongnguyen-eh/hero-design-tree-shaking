import {
  useLayoutEffect,
  useMemo,
  useEffect,
  useState,
  useCallback,
  useRef,
} from 'react';
import { useTheme } from 'styled-components';
import type { EffectCallback, RefObject, SetStateAction } from 'react';
import { isNonEmptyArray } from '../fp/NonEmptyArray';
import css from './css';
import type { SxObject } from '../components/common';
import { getMediaQuery } from './responsiveBreakpoints';

type Dimensions = {
  clientWidth: number;
  height: number;
  scrollWidth: number;
  width: number;
};

const useNativeResizeObserver = (
  resizeCallback: (dimensions: Dimensions) => void,
  refElement: HTMLElement | null
): void => {
  useLayoutEffect(() => {
    if (refElement === null) return;
    const resizeObserver = new ResizeObserver((entries) => {
      if (isNonEmptyArray(entries)) {
        const targetElement = entries[0].target as HTMLElement;
        resizeCallback({
          height: targetElement.offsetHeight,
          width: targetElement.offsetWidth,
          clientWidth: targetElement.clientWidth,
          scrollWidth: targetElement.scrollWidth,
        });
      }
    });

    resizeObserver.observe(refElement);

    return (): void => resizeObserver.unobserve(refElement);
  }, [resizeCallback, refElement]);
};

const useCustomResizeObserver = (
  resizeCallback: (dimensions: Dimensions) => void,
  refElement: HTMLElement | null
): void => {
  const width = refElement !== null ? refElement.offsetWidth : 0;
  const height = refElement !== null ? refElement.offsetHeight : 0;
  const clientWidth = refElement !== null ? refElement.clientWidth : 0;
  const scrollWidth = refElement !== null ? refElement.scrollWidth : 0;

  useLayoutEffect(() => {
    resizeCallback({ width, height, clientWidth, scrollWidth });
  }, [width, height, resizeCallback, clientWidth, scrollWidth]);
};

const useResizeObserver = (
  resizeCallback: (dimensions: Dimensions) => void,
  refElement: HTMLElement | null
): void => {
  const observer = useMemo(() => {
    return typeof window !== 'undefined' && window.ResizeObserver !== undefined
      ? useNativeResizeObserver
      : useCustomResizeObserver;
  }, []);
  observer(resizeCallback, refElement);
};

const useHover = (ref: RefObject<HTMLElement>) => {
  const [value, setValue] = useState<boolean>(false);
  const handleMouseEnter = () => setValue(true);
  const handleMouseLeave = () => setValue(false);

  useEffect((): ReturnType<EffectCallback> => {
    const node = ref.current;
    if (node !== null) {
      node.addEventListener('mouseenter', handleMouseEnter);
      node.addEventListener('mouseleave', handleMouseLeave);
      return () => {
        node.removeEventListener('mouseenter', handleMouseEnter);
        node.removeEventListener('mouseleave', handleMouseLeave);
      };
    }
  }, [ref]);
  return value;
};

const getMatches = (query: string): boolean => {
  // Prevents SSR issues
  if (typeof window !== 'undefined') {
    return window.matchMedia(query).matches;
  }
  return false;
};

const useMediaQuery = (query: string): boolean => {
  const [matches, setMatches] = useState<boolean>(getMatches(query));

  const handleChange = useCallback(() => {
    setMatches(getMatches(query));
  }, [query]);

  useEffect(() => {
    const matchMedia = window.matchMedia(query);

    // Triggered at the first client-side load and if query changes
    handleChange();

    matchMedia.addEventListener('change', handleChange);

    return () => {
      matchMedia.removeEventListener('change', handleChange);
    };
  }, [query, handleChange]);

  return matches;
};

const useSizeMediaQuery = (): 'small' | 'medium' | 'large' | 'xlarge' => {
  const theme = useTheme();
  const isSmall = useMediaQuery(getMediaQuery('small', theme));
  const isMedium = useMediaQuery(getMediaQuery('medium', theme));
  const isLarge = useMediaQuery(getMediaQuery('large', theme));
  const isXLarge = useMediaQuery(getMediaQuery('xlarge', theme));

  if (isXLarge) return 'xlarge';
  if (isLarge) return 'large';
  if (isMedium) return 'medium';
  if (isSmall) return 'small';
  return 'small';
};

const useDeprecation = (message: string, cond = true) => {
  useEffect(() => {
    if (process.env['NODE_ENV'] === 'development' && cond === true) {
      // eslint-disable-next-line no-console
      console.warn(
        `%c
██████╗ ███████╗██████╗ ██████╗ ███████╗ ██████╗ █████╗ ████████╗███████╗██████╗
██╔══██╗██╔════╝██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗╚══██╔══╝██╔════╝██╔══██╗
██║  ██║█████╗  ██████╔╝██████╔╝█████╗  ██║     ███████║   ██║   █████╗  ██║  ██║
██║  ██║██╔══╝  ██╔═══╝ ██╔══██╗██╔══╝  ██║     ██╔══██║   ██║   ██╔══╝  ██║  ██║
██████╔╝███████╗██║     ██║  ██║███████╗╚██████╗██║  ██║   ██║   ███████╗██████╔╝
╚═════╝ ╚══════╝╚═╝     ╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═════╝
%c${message}`,
        'color: red',
        'color: red; font-size: 15px'
      );
    }
  }, [message, cond]);
};

const useCss = (sx: SxObject) => {
  const theme = useTheme();
  return useMemo(() => css(sx, theme), [sx]);
};

const useIsomorphicLayoutEffect =
  typeof window !== 'undefined' ? useLayoutEffect : useEffect;

// MediaQueryList Event based useEventListener interface
function useEventListener<K extends keyof MediaQueryListEventMap>(
  eventName: K,
  handler: (event: MediaQueryListEventMap[K]) => void,
  element: RefObject<MediaQueryList>,
  options?: boolean | AddEventListenerOptions
): void;

// Window Event based useEventListener interface
function useEventListener<K extends keyof WindowEventMap>(
  eventName: K,
  handler: (event: WindowEventMap[K]) => void,
  element?: undefined,
  options?: boolean | AddEventListenerOptions
): void;

// Element Event based useEventListener interface
function useEventListener<
  K extends keyof HTMLElementEventMap,
  T extends HTMLElement = HTMLDivElement
>(
  eventName: K,
  handler: (event: HTMLElementEventMap[K]) => void,
  element: RefObject<T>,
  options?: boolean | AddEventListenerOptions
): void;

// Document Event based useEventListener interface
function useEventListener<K extends keyof DocumentEventMap>(
  eventName: K,
  handler: (event: DocumentEventMap[K]) => void,
  element: RefObject<Document>,
  options?: boolean | AddEventListenerOptions
): void;

function useEventListener<
  KW extends keyof WindowEventMap,
  KH extends keyof HTMLElementEventMap,
  KM extends keyof MediaQueryListEventMap,
  T extends HTMLElement | MediaQueryList | void = void
>(
  eventName: KW | KH | KM,
  handler: (
    event:
      | WindowEventMap[KW]
      | HTMLElementEventMap[KH]
      | MediaQueryListEventMap[KM]
      | Event
  ) => void,
  element?: RefObject<T>,
  options?: boolean | AddEventListenerOptions
) {
  // Create a ref that stores handler
  const savedHandler = useRef(handler);

  useIsomorphicLayoutEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  useEffect(() => {
    // Define the listening target
    const targetElement: T | Window = element?.current ?? window;

    if (!(targetElement && targetElement.addEventListener)) return;

    // Create event listener that calls handler function stored in ref
    const listener: typeof handler = (event) => savedHandler.current(event);

    targetElement.addEventListener(eventName, listener, options);

    // Remove event listener on cleanup
    return () => {
      targetElement.removeEventListener(eventName, listener, options);
    };
  }, [eventName, element, options]);
}

type Handler = (event: MouseEvent) => void;

export function useOnClickOutside<T extends HTMLElement = HTMLElement>(
  ref: RefObject<T>,
  handler: Handler,
  mouseEvent: 'mousedown' | 'mouseup' = 'mousedown'
): void {
  useEventListener(mouseEvent, (event) => {
    const el = ref?.current;

    // Do nothing if clicking ref's element or descendent elements
    if (!el || el.contains(event.target as Node)) {
      return;
    }

    handler(event);
  });
}
interface UseControllableStateProps<T> {
  value?: T;
  defaultValue?: T;
  onChange?: (value: T) => void;
}

type UpdaterFunction<T> = (prevState: T) => T;

const useControllableState = <T>({
  defaultValue,
  value: controlledValue,
  onChange: onControlledChange,
}: UseControllableStateProps<T>): [T, React.Dispatch<SetStateAction<T>>] => {
  const [internalState, setInternalState] = useState<T>(defaultValue as T);
  const isControlled = controlledValue !== undefined;
  const value = isControlled ? controlledValue : internalState;

  const setValue = useCallback(
    (valueOrUpdater) => {
      const updater =
        typeof valueOrUpdater === 'function'
          ? (valueOrUpdater as UpdaterFunction<T>)
          : () => valueOrUpdater;
      const nextValue = updater(value);

      if (isControlled) {
        onControlledChange?.(nextValue);
      } else {
        setInternalState(nextValue);
      }
    },
    [isControlled, onControlledChange, value]
  );

  return [value, setValue];
};

const useBoolean = (initialValue = false) => {
  const [value, setValue] = useState<boolean>(initialValue);

  const actions = useMemo(
    () => ({
      on: () => setValue(true),
      off: () => setValue(false),
      toggle: () => setValue((prevValue) => !prevValue),
    }),
    []
  );

  return [value, actions] as const;
};

export {
  useResizeObserver,
  useHover,
  useMediaQuery,
  useDeprecation,
  useCss,
  useIsomorphicLayoutEffect,
  useEventListener,
  useSizeMediaQuery,
  useControllableState,
  useBoolean,
};
