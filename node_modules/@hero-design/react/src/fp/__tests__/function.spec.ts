import {
  pipe,
  flow,
  noop,
  always,
  invokeWith,
  invoke,
  equal,
  isDefined,
  camelize,
} from '../function';

describe('pipe', () => {
  it('works with 1 arg', () => {
    expect(pipe(1)).toBe(1);
  });

  it('works with 2 args', () => {
    expect(pipe(1, (a) => a + 1)).toBe(2);
  });

  it('works with 3 args', () => {
    expect(
      pipe(
        1,
        (a: number) => a + 1,
        (b: number) => b * 2
      )
    ).toBe(4);
  });

  it('works with 4 args', () => {
    expect(
      pipe(
        1,
        (a: number) => a + 1,
        (b: number) => b * 2,
        (c: number) => c - 1
      )
    ).toBe(3);
  });

  it('works with 5 args', () => {
    expect(
      pipe(
        1,
        (a: number) => a + 1,
        (b: number) => b * 2,
        (c: number) => c - 1,
        (d: number) => d / 3
      )
    ).toBe(1);
  });

  it('throws error with 6 args', () => {
    expect(() =>
      pipe(
        1,
        (a: number) => a + 1,
        (b: number) => b * 2,
        (c: number) => c - 1,
        (d: number) => d / 3,
        // Just for testing purpose, TS can't use pipe with 6 arguments
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        (e: number) => e + 2
      )
    ).toThrow('Pipe with 6 arguments is not implemented yet!');
  });
});

describe('flow', () => {
  it('works with 1 arg', () => {
    expect(flow((a: number) => a + 1)(1)).toBe(2);
  });

  it('works with 2 args', () => {
    expect(
      flow(
        (a: number) => a + 1,
        (b: number) => b * 2
      )(1)
    ).toBe(4);
  });

  it('works with 3 args', () => {
    expect(
      flow(
        (a: number) => a + 1,
        (b: number) => b * 2,
        (c: number) => c - 1
      )(1)
    ).toBe(3);
  });

  it('works with 4 args', () => {
    expect(
      flow(
        (a: number) => a + 1,
        (b: number) => b * 2,
        (c: number) => c - 1,
        (d: number) => d / 3
      )(1)
    ).toBe(1);
  });

  it('throws error with 5 args', () => {
    expect(() =>
      flow(
        (a: number) => a + 1,
        (b: number) => b * 2,
        (c: number) => c - 1,
        (d: number) => d / 3,
        // Just for testing purpose, TS can't use flow with 5 arguments
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        (e: number) => e + 2
      )(1)
    ).toThrow('Flow with 5 arguments is not implemented yet!');
  });
});

describe('noop', () => {
  it('returns nothing', () => {
    expect(noop()).toBe(undefined);
  });
});

describe('always', () => {
  it('returns fixed value regardless to the input', () => {
    expect(always(1)(2)).toBe(1);
    expect(always(1)(3)).toBe(1);
  });
});

describe('invokeWith', () => {
  it('passes value to invoke the function', () => {
    expect(invokeWith(1)((a: number) => a + 1)).toBe(2);
  });
});

describe('invoke', () => {
  it('invokes the function on value', () => {
    expect(invoke((a: number) => a + 1)(1)).toBe(2);
  });
});

describe('equal', () => {
  it('does shalow comparison', () => {
    expect(equal(1)(1)).toBe(true);
    expect(equal(1)(2)).toBe(false);
    expect(equal({ foo: 1 })({ foo: 1 })).toBe(false);
  });
});

describe('isDefined', () => {
  it('returns true on defined value', () => {
    expect(isDefined(1)).toBe(true);
    expect(isDefined(true)).toBe(true);
    expect(isDefined({ foo: 1 })).toBe(true);
  });

  it('returns false on undefined', () => {
    expect(isDefined(undefined)).toBe(false);
  });

  it('returns false on null', () => {
    expect(isDefined(null)).toBe(false);
  });
});

describe('camelize', () => {
  it.each`
    input      | output
    ${'a-b'}   | ${'aB'}
    ${'a-b-c'} | ${'aBC'}
    ${'a-bC'}  | ${'aBC'}
    ${'ab'}    | ${'ab'}
    ${'aB'}    | ${'aB'}
    ${''}      | ${''}
  `('returns $output when input is $input ', ({ input, output }) => {
    expect(camelize(input)).toEqual(output);
  });
});
