type PipeFn = (input: unknown) => unknown;

/* eslint-disable no-shadow, @typescript-eslint/no-non-null-assertion, no-unused-vars, no-redeclare */
export function pipe<A>(a: A): A;
export function pipe<A, B>(a: A, ab: (a: A) => B): B;
export function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C;
export function pipe<A, B, C, D>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D
): D;
export function pipe<A, B, C, D, E>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E
): E;
export function pipe(a: unknown, ...fns: PipeFn[]): unknown {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return fns[0](a);
    case 3:
      return fns[1](fns[0](a));
    case 4:
      return fns[2](fns[1](fns[0](a)));
    case 5:
      return fns[3](fns[2](fns[1](fns[0](a))));
  }
  throw new Error(
    `Pipe with ${arguments.length} arguments is not implemented yet!`
  );
}

type FlowFn = (...args: Array<unknown>) => unknown;

export function flow<A extends ReadonlyArray<unknown>, B>(
  ab: (...a: A) => B
): (...a: A) => B;
export function flow<A extends ReadonlyArray<unknown>, B, C>(
  ab: (...a: A) => B,
  bc: (b: B) => C
): (...a: A) => C;
export function flow<A extends ReadonlyArray<unknown>, B, C, D>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D
): (...a: A) => D;
export function flow<A extends ReadonlyArray<unknown>, B, C, D, E>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E
): (...a: A) => E;
export function flow(...fns: FlowFn[]): unknown {
  switch (arguments.length) {
    case 1:
      return fns[0];
    case 2:
      return (...args: Array<unknown>) => fns[1](fns[0](...args));
    case 3:
      return (...args: Array<unknown>) => fns[2](fns[1](fns[0](...args)));
    case 4:
      return (...args: Array<unknown>) =>
        fns[3](fns[2](fns[1](fns[0](...args))));
  }
  throw new Error(
    `Flow with ${arguments.length} arguments is not implemented yet!`
  );
}
/* eslint-enable no-shadow, @typescript-eslint/no-non-null-assertion */

// eslint-disable-next-line @typescript-eslint/no-empty-function
export const noop = (): void => {
  // Intentionally left empty, used for event handlers that do nothing in some specific cases.
};

export const always =
  <A>(a: A) =>
  (_b: any) =>
    a;

export const invokeWith =
  <A, B>(a: A) =>
  (fn: (fa: A) => B) =>
    fn(a);

export const invoke =
  <A, B>(fn: (a: A) => B) =>
  (a: A) =>
    fn(a);

export const equal =
  <A>(a1: A) =>
  (a2: A) =>
    a1 === a2;

export const isDefined = <A>(a: A) => a !== null && a !== undefined;

export const camelize = (s: string): string =>
  s.replace(/-./g, (x) => {
    const [, match] = x;
    if (match !== undefined) {
      return match.toUpperCase();
    }
    return '';
  });
