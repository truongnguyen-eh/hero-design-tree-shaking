import type { Lazy } from './Lazy';

export interface None {
  readonly tag: 'None';
}

export interface Some<A> {
  readonly tag: 'Some';
  readonly value: A;
}

export type Option<A> = None | Some<A>;

export const none: Option<never> = { tag: 'None' };

export const some = <A>(a: A): Option<A> => ({ tag: 'Some', value: a });

export const isSome = <A>(ma: Option<A>): ma is Some<A> => ma.tag === 'Some';

export const isNone = <A>(ma: Option<A>): ma is None => ma.tag === 'None';

export function fromUndefinedable<A>(a: A): Option<NonNullable<A>> {
  return a === undefined ? none : some(a as NonNullable<A>);
}

export function fromNullable<A>(a: A): Option<NonNullable<A>> {
  return a === null ? none : some(a as NonNullable<A>);
}

export function fromNillable<A>(a: A): Option<NonNullable<A>> {
  return a === null || a === undefined ? none : some(a as NonNullable<A>);
}

export function toNullable<A>(ma: Option<A>): A | null {
  return isNone(ma) ? null : ma.value;
}

export function toUndefinedable<A>(ma: Option<A>): A | undefined {
  return isNone(ma) ? undefined : ma.value;
}

export const map =
  <A, B>(f: (a: A) => B) =>
  (ma: Option<A>) =>
    isNone(ma) ? none : some(f(ma.value));

export const flatMap =
  <A, B>(f: (a: A) => Option<B>) =>
  (ma: Option<A>) => {
    if (isNone(ma)) {
      return none;
    }
    const mb = f(ma.value);
    if (isNone(mb)) {
      return none;
    }

    return some(mb.value);
  };

export const getOrElse =
  <A>(onNone: Lazy<A>) =>
  <B>(mb: Option<B>): A | B =>
    isNone(mb) ? onNone() : mb.value;
